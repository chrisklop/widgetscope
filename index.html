<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WidgetScope - Webex Connect Debug Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0d0d0d;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 15px;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 200px 1fr 1fr 280px;
            grid-template-rows: calc(50vh - 40px) calc(50vh - 40px);
            gap: 12px;
            height: calc(100vh - 75px);
            overflow: hidden;
            margin-right: 25%;  /* Reserve right quarter for chatbot widget */
            margin-top: 60px;  /* Space for nav bar */
        }

        /* WS/MQTT Split Panel */
        .ws-mqtt-split {
            display: flex;
            flex-direction: column;
            gap: 8px;
            grid-row: 1 / 3;  /* Span both rows */
        }

        .ws-mqtt-split .split-panel {
            flex: 1;
            background: #141414;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .ws-mqtt-split .split-panel .panel-header {
            padding: 8px 12px;
            background: #1a1a1a;
            border-bottom: 1px solid #252525;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .ws-mqtt-split .split-panel .panel-title {
            color: #fff;
            font-size: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .ws-mqtt-split .split-panel .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            font-size: 0.65rem;
            min-height: 0;
        }

        .ws-mqtt-split .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #1f1f1f;
        }

        .ws-mqtt-split .metric-label {
            color: #888;
        }

        .ws-mqtt-split .metric-value {
            color: #fff;
            font-weight: 500;
        }

        .ws-mqtt-split .metric-value.success { color: #28a745; }
        .ws-mqtt-split .metric-value.warning { color: #f59e0b; }
        .ws-mqtt-split .metric-value.error { color: #ef4444; }

        .ws-mqtt-split .mini-log {
            margin-top: 8px;
            max-height: none;
            flex: 1;
            overflow-y: auto;
            background: #0d0d0d;
            border-radius: 6px;
            padding: 6px;
        }

        /* Boolean value highlighting */
        .bool-true {
            color: #28a745;
            font-weight: 600;
        }
        .bool-false {
            color: #dc3545;
            font-weight: 600;
        }

        /* Help Button - In Nav */
        .help-btn {
            background: #1a1a1a;
            color: #00d4aa;
            border: 1px solid #2a2a2a;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s ease;
        }
        .help-btn:hover {
            background: #252525;
            border-color: #00d4aa;
        }

        /* Top Navigation Bar */
        .top-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 25%;
            height: 45px;
            background: #141414;
            border-bottom: 1px solid #1f1f1f;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 999;
        }
        .nav-brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .nav-brand h1 {
            color: #fff;
            font-size: 0.95rem;
            margin: 0;
        }
        .nav-brand .badge {
            margin: 0;
        }
        .nav-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .nav-btn {
            background: #1a1a1a;
            border: 1px solid #252525;
            color: #888;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s;
        }
        .nav-btn:hover {
            background: #252525;
            color: #fff;
            border-color: #333;
        }
        .nav-btn.primary {
            background: #00d4aa;
            color: #0d0d0d;
            border-color: #00d4aa;
        }
        .nav-btn.primary:hover {
            background: #00b894;
        }
        .nav-btn.danger {
            color: #ef4444;
        }
        .nav-btn.danger:hover {
            background: #1c1414;
            border-color: #ef4444;
        }
        .nav-divider {
            width: 1px;
            height: 24px;
            background: #252525;
            margin: 0 6px;
        }

        /* Mini Status Orb in Nav Bar */
        .nav-status-orb {
            width: 28px;
            height: 28px;
            position: relative;
            cursor: pointer;
            margin-left: 12px;
        }
        .nav-orb-core {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: #00d4aa;
            box-shadow: 0 0 12px rgba(0, 212, 170, 0.6);
            transition: background 0.5s ease, box-shadow 0.5s ease;
        }
        .nav-orb-core.warning {
            background: #f59e0b;
            box-shadow: 0 0 12px rgba(245, 158, 11, 0.6);
        }
        .nav-orb-core.error {
            background: #ef4444;
            box-shadow: 0 0 12px rgba(239, 68, 68, 0.6);
        }
        .nav-orb-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 22px;
            height: 22px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 2px solid rgba(0, 212, 170, 0.4);
            animation: orb-pulse 2s ease-in-out infinite;
        }
        .nav-orb-ring.warning {
            border-color: rgba(245, 158, 11, 0.4);
        }
        .nav-orb-ring.error {
            border-color: rgba(239, 68, 68, 0.4);
        }
        @keyframes orb-pulse {
            0%, 100% {
                opacity: 0.3;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.1);
            }
        }
        .nav-status-text {
            font-size: 0.7rem;
            color: #00d4aa;
            font-weight: 600;
            margin-left: 6px;
        }
        .nav-status-text.warning {
            color: #f59e0b;
        }
        .nav-status-text.error {
            color: #ef4444;
        }

        /* Help Panel - Slides from Left */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 75%;
            height: 100vh;
            background: rgba(0,0,0,0.5);
            z-index: 9998;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
        }
        .help-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .help-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 70%;
            max-width: 900px;
            height: 100vh;
            background: #141414;
            z-index: 9999;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            display: flex;
            box-shadow: 5px 0 30px rgba(0,0,0,0.5);
        }
        .help-panel.show {
            transform: translateX(0);
        }

        /* Help Navigation Sidebar */
        .help-nav {
            width: 220px;
            background: #0d0d0d;
            padding: 20px 0;
            overflow-y: auto;
            flex-shrink: 0;
        }
        .help-nav-header {
            padding: 0 20px 20px;
            border-bottom: 1px solid #1f1f1f;
            margin-bottom: 10px;
        }
        .help-nav-header h2 {
            color: #fff;
            font-size: 1.1rem;
            margin-bottom: 4px;
        }
        .help-nav-header p {
            color: #666;
            font-size: 0.7rem;
        }
        .help-nav-section {
            padding: 8px 20px;
            color: #00d4aa;
            font-size: 0.65rem;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .help-nav-item {
            padding: 10px 20px;
            color: #888;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }
        .help-nav-item:hover {
            background: #1a1a1a;
            color: #fff;
        }
        .help-nav-item.active {
            background: #1a1a1a;
            color: #00d4aa;
            border-left-color: #00d4aa;
        }

        /* Help Content Area */
        .help-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }
        .help-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #1f1f1f;
            border: none;
            color: #666;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
        }
        .help-close:hover {
            background: #00d4aa;
            color: #0d0d0d;
        }

        .help-section {
            display: none;
        }
        .help-section.active {
            display: block;
        }
        .help-section h2 {
            color: #fff;
            font-size: 1.4rem;
            margin-bottom: 8px;
        }
        .help-section h3 {
            color: #00d4aa;
            font-size: 1rem;
            margin: 24px 0 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #1f1f1f;
        }
        .help-section h4 {
            color: #fff;
            font-size: 0.9rem;
            margin: 16px 0 8px;
        }
        .help-section p {
            color: #bbb;
            font-size: 0.85rem;
            line-height: 1.6;
            margin-bottom: 12px;
        }
        .help-section ul, .help-section ol {
            color: #bbb;
            font-size: 0.85rem;
            line-height: 1.8;
            margin: 12px 0 12px 20px;
        }
        .help-section li {
            margin-bottom: 6px;
        }
        .help-section code {
            background: #1f1f1f;
            color: #00d4aa;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
        }
        .help-section pre {
            background: #0d0d0d;
            border: 1px solid #1f1f1f;
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
            margin: 12px 0;
        }
        .help-section pre code {
            background: none;
            padding: 0;
            color: #7dd3c0;
            font-size: 0.75rem;
            line-height: 1.5;
        }
        .help-tip {
            background: rgba(0, 212, 170, 0.08);
            border-left: 4px solid #00d4aa;
            padding: 12px 16px;
            border-radius: 0 8px 8px 0;
            margin: 16px 0;
        }
        .help-tip p {
            color: #ddd;
            margin: 0;
        }
        .help-warning {
            background: rgba(255, 193, 7, 0.1);
            border-left: 4px solid #ffc107;
            padding: 12px 16px;
            border-radius: 0 8px 8px 0;
            margin: 16px 0;
        }
        .help-warning p {
            color: #ffc107;
            margin: 0;
        }
        .help-link {
            color: #00d4aa;
            text-decoration: none;
        }
        .help-link:hover {
            text-decoration: underline;
        }
        .tool-card {
            background: #1a1a1a;
            border: 1px solid #252525;
            border-radius: 10px;
            padding: 16px;
            margin: 12px 0;
        }
        .tool-card h4 {
            color: #00d4aa;
            margin: 0 0 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tool-card p {
            margin: 0;
            font-size: 0.8rem;
        }
        .config-table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 0.8rem;
        }
        .config-table th, .config-table td {
            border: 1px solid #252525;
            padding: 10px;
            text-align: left;
        }
        .config-table th {
            background: #1a1a1a;
            color: #00d4aa;
            font-weight: 600;
        }
        .config-table td {
            color: #bbb;
        }
        .config-table code {
            font-size: 0.75rem;
        }

        /* Left Sidebar - Status & Controls */
        .sidebar {
            grid-row: 1 / 3;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            max-height: calc(100vh - 30px);
        }

        .container {
            background: #141414;
            border-radius: 12px;
            padding: 16px;
            border: 1px solid #1f1f1f;
        }

        h1 {
            color: #ffffff;
            font-size: 1.2rem;
            margin-bottom: 4px;
        }

        .subtitle {
            color: #666;
            font-size: 0.8rem;
            margin-bottom: 12px;
        }

        .status-card {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: #28a745;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            background: #ffc107;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .badge {
            display: inline-block;
            background: #1f1f1f;
            color: #00d4aa;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 0.65rem;
            font-weight: 600;
            margin-bottom: 10px;
            border: 1px solid #2a2a2a;
        }

        .debug-badge {
            background: #1f1f1f;
            color: #f59e0b;
            border: 1px solid #2a2a2a;
            margin-left: 6px;
        }

        /* State Grid */
        .state-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .state-item {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 6px;
        }

        .state-label {
            color: #666;
            font-size: 0.6rem;
            margin-bottom: 2px;
            text-transform: uppercase;
        }

        .state-value {
            color: #e0e0e0;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .state-value.online { color: #28a745; }
        .state-value.offline { color: #dc3545; }
        .state-value.pending { color: #ffc107; }

        /* Controls */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-btn {
            background: #00d4aa;
            border: none;
            color: #0d0d0d;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .control-btn:hover {
            background: #00b894;
            transform: translateY(-1px);
        }

        .control-btn.secondary {
            background: #1f1f1f;
            color: #888;
            border: 1px solid #2a2a2a;
        }

        .control-btn.secondary:hover {
            background: #252525;
            color: #fff;
        }

        .btn-row {
            display: flex;
            gap: 6px;
        }

        .btn-row .control-btn {
            flex: 1;
        }

        /* Widget Config Panel */
        .config-panel {
            background: #141414;
            border-radius: 10px;
            padding: 12px;
            border: 1px solid #1f1f1f;
        }

        .config-panel h3 {
            color: #fff;
            font-size: 0.8rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #333;
            font-size: 0.7rem;
        }

        .config-item:last-child {
            border-bottom: none;
        }

        .config-label {
            color: #888;
        }

        .config-value {
            color: #7dd3c0;
            font-family: 'Monaco', 'Menlo', monospace;
            max-width: 140px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .config-value.success { color: #28a745; }
        .config-value.warning { color: #ffc107; }
        .config-value.online { color: #28a745; }
        .config-value.offline { color: #ef4444; }

        /* Collapsible Section Styles */
        .config-panel.collapsible .section-header {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            user-select: none;
            transition: color 0.2s;
        }

        .config-panel.collapsible .section-header:hover {
            color: #00d4aa;
        }

        .section-icon {
            font-size: 0.85rem;
        }

        .section-toggle {
            margin-left: auto;
            font-size: 0.6rem;
            color: #666;
            transition: transform 0.2s;
        }

        .config-panel.collapsible.collapsed .section-toggle {
            transform: rotate(-90deg);
        }

        .config-panel.collapsible.collapsed .section-content {
            display: none;
        }

        .config-panel.collapsible.collapsed .section-summary {
            display: flex;
        }

        /* Section Summary (visible when collapsed) */
        .section-summary {
            display: none;
            gap: 6px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .metric-badge {
            background: #1f1f1f;
            color: #888;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.6rem;
            font-weight: 600;
        }

        .metric-badge.online,
        .metric-badge.visible {
            background: rgba(40, 167, 69, 0.2);
            color: #28a745;
        }

        .metric-badge.offline,
        .metric-badge.hidden {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .metric-badge.warning {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        /* Status Indicator Dot */
        .section-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            margin-left: 4px;
            flex-shrink: 0;
        }

        .section-status.warning {
            background: #f59e0b;
        }

        .section-status.error {
            background: #ef4444;
        }

        .section-status.unknown {
            background: #666;
        }

        /* Mini-Log Container */
        .mini-log {
            max-height: 150px;
            overflow-y: auto;
            background: #0d0d0d;
            border-radius: 6px;
            margin-top: 8px;
            padding: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.6rem;
        }

        .mini-log::-webkit-scrollbar {
            width: 4px;
        }

        .mini-log::-webkit-scrollbar-track {
            background: #0d0d0d;
        }

        .mini-log::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 2px;
        }

        /* Mini-Log Entry */
        .mini-log-entry {
            padding: 3px 6px;
            border-left: 2px solid #3a3a3a;
            margin: 2px 0;
            background: #141414;
            border-radius: 0 3px 3px 0;
        }

        .mini-log-entry.ws-open,
        .mini-log-entry.vis-visible,
        .mini-log-entry.net-online {
            border-left-color: #28a745;
        }

        .mini-log-entry.ws-close,
        .mini-log-entry.ws-error,
        .mini-log-entry.net-offline {
            border-left-color: #ef4444;
        }

        .mini-log-entry.ws-message {
            border-left-color: #06b6d4;
        }

        .mini-log-entry.ws-zombie,
        .mini-log-entry.vis-hidden {
            border-left-color: #f59e0b;
        }

        .mini-log-time {
            color: #666;
            font-size: 0.55rem;
        }

        .mini-log-msg {
            color: #bbb;
            word-break: break-all;
        }

        .mini-log-data {
            color: #7dd3c0;
            font-size: 0.55rem;
            margin-top: 2px;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* WebSocket Direction Indicators */
        .ws-direction {
            display: inline-block;
            width: 14px;
            text-align: center;
            margin-right: 4px;
        }

        .ws-direction.sent {
            color: #f59e0b;
        }

        .ws-direction.received {
            color: #06b6d4;
        }

        /* MQTT Packet Type Badges */
        .mqtt-packet-type {
            display: inline-block;
            font-size: 0.55rem;
            font-weight: 600;
            padding: 1px 5px;
            border-radius: 3px;
            margin-right: 4px;
            text-transform: uppercase;
        }

        .mqtt-packet-type.connect { background: #2563eb; color: #fff; }
        .mqtt-packet-type.connack { background: #16a34a; color: #fff; }
        .mqtt-packet-type.publish { background: #7c3aed; color: #fff; }
        .mqtt-packet-type.puback { background: #9333ea; color: #fff; }
        .mqtt-packet-type.subscribe { background: #0891b2; color: #fff; }
        .mqtt-packet-type.suback { background: #06b6d4; color: #fff; }
        .mqtt-packet-type.unsubscribe { background: #dc2626; color: #fff; }
        .mqtt-packet-type.unsuback { background: #ef4444; color: #fff; }
        .mqtt-packet-type.pingreq { background: #65a30d; color: #fff; }
        .mqtt-packet-type.pingresp { background: #84cc16; color: #000; }
        .mqtt-packet-type.disconnect { background: #6b7280; color: #fff; }
        .mqtt-packet-type.unknown { background: #374151; color: #fff; }

        .mqtt-topic {
            color: #fbbf24;
            font-size: 0.55rem;
            font-family: monospace;
        }

        .mqtt-qos {
            color: #94a3b8;
            font-size: 0.5rem;
        }

        .mqtt-payload-preview {
            color: #7dd3c0;
            font-size: 0.55rem;
            margin-top: 2px;
            padding: 2px 4px;
            background: rgba(125, 211, 192, 0.1);
            border-radius: 2px;
            max-height: 40px;
            overflow: hidden;
        }

        .mini-log-entry.mqtt-connect { border-left-color: #2563eb; }
        .mini-log-entry.mqtt-connack { border-left-color: #16a34a; }
        .mini-log-entry.mqtt-publish { border-left-color: #7c3aed; }
        .mini-log-entry.mqtt-subscribe { border-left-color: #0891b2; }
        .mini-log-entry.mqtt-ping { border-left-color: #65a30d; }
        .mini-log-entry.mqtt-disconnect { border-left-color: #6b7280; }
        .mini-log-entry.mqtt-error { border-left-color: #ef4444; }

        .mqtt-connection-indicator {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-bottom: 6px;
        }

        .mqtt-connection-indicator.connected {
            background: rgba(22, 163, 74, 0.2);
            color: #22c55e;
        }

        .mqtt-connection-indicator.disconnected {
            background: rgba(107, 114, 128, 0.2);
            color: #9ca3af;
        }

        .mqtt-connection-indicator.connecting {
            background: rgba(37, 99, 235, 0.2);
            color: #3b82f6;
        }

        /* Filter Toggle */
        .filter-section {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .filter-section h4 {
            color: #fff;
            font-size: 0.7rem;
            margin-bottom: 8px;
        }

        .filter-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.7rem;
            color: #aaa;
            cursor: pointer;
        }

        .filter-toggle input {
            cursor: pointer;
        }

        .filter-stats {
            font-size: 0.65rem;
            color: #666;
            margin-top: 6px;
        }

        /* Panel containers */
        .panel-container {
            display: flex;
            flex-direction: column;
            max-height: calc(50vh - 25px);
            overflow: hidden;
        }

        /* Debug Panel Styles */
        .debug-panel {
            background: #141414;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 0;
            flex: 1;
            max-height: 100%;
            border: 1px solid #1f1f1f;
        }

        .panel-header {
            background: #1a1a1a;
            padding: 8px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #1f1f1f;
            flex-shrink: 0;
        }

        .panel-title {
            color: #fff;
            font-size: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .panel-actions {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .panel-count {
            background: #00d4aa;
            color: #0d0d0d;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.6rem;
            font-weight: 600;
        }

        .panel-count.filtered {
            background: #3a3a3a;
            color: #888;
        }

        .copy-btn {
            background: #1f1f1f;
            border: 1px solid #2a2a2a;
            color: #666;
            padding: 3px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            gap: 3px;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #252525;
            color: #fff;
            border-color: #3a3a3a;
        }

        .copy-btn.copied {
            background: #00d4aa;
            color: #0d0d0d;
            border-color: #00d4aa;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 6px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.68rem;
            line-height: 1.4;
            min-height: 0;
            max-height: 100%;
        }

        .log-entry {
            padding: 6px 8px;
            margin: 3px 0;
            border-radius: 5px;
            background: #1a1a1a;
            border-left: 3px solid #3a3a3a;
            position: relative;
        }

        .log-entry:hover .entry-copy-btn {
            opacity: 1;
        }

        .log-entry.collapsed {
            opacity: 0.6;
            padding: 4px 8px;
        }

        .collapse-count {
            background: #00d4aa;
            color: #0d0d0d;
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 0.6rem;
            margin-left: 8px;
            font-weight: 600;
        }

        .entry-copy-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            opacity: 0;
            transition: opacity 0.2s;
            background: #252525;
            border: none;
            color: #666;
            padding: 2px 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.55rem;
        }

        .entry-copy-btn:hover {
            background: #3a3a3a;
            color: #fff;
        }

        .entry-copy-btn.copied {
            background: #00d4aa;
            color: #0d0d0d;
            opacity: 1;
        }

        .log-entry.error {
            border-left-color: #ef4444;
            background: #1c1414;
        }

        .log-entry.warn {
            border-left-color: #f59e0b;
            background: #1c1a14;
        }

        .log-entry.success {
            border-left-color: #00d4aa;
            background: #141c1a;
        }

        .log-entry.postmessage {
            border-left-color: #06b6d4;
            background: #141a1c;
        }

        .log-entry.widget-message {
            border-left-color: #00d4aa;
            background: #141c1a;
            border-left-width: 4px;
        }

        .log-entry.browser-noise {
            border-left-color: #4a4a4a;
            background: #181818;
            opacity: 0.7;
        }

        .log-entry.network {
            border-left-color: #f59e0b;
            background: #1c1a14;
        }

        .source-tag {
            display: inline-block;
            padding: 1px 5px;
            border-radius: 3px;
            font-size: 0.55rem;
            margin-right: 6px;
            font-weight: 600;
        }

        .source-tag.widget {
            background: #00d4aa;
            color: #0d0d0d;
        }

        .source-tag.browser {
            background: #4a4a4a;
            color: #ccc;
        }

        .source-tag.debug {
            background: #06b6d4;
            color: #0d0d0d;
        }

        .log-time {
            color: #888;
            font-size: 0.55rem;
            margin-bottom: 2px;
        }

        .log-message {
            color: #e0e0e0;
            word-break: break-all;
        }

        .log-json {
            color: #7dd3c0;
            background: #0d0d0d;
            padding: 6px;
            border-radius: 4px;
            margin-top: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            font-size: 0.62rem;
        }

        /* Quick Actions Panel */
        .quick-actions {
            background: #141414;
            border-radius: 10px;
            padding: 12px;
            flex-shrink: 0;
            border: 1px solid #1f1f1f;
        }

        .quick-actions h3 {
            color: #fff;
            font-size: 0.8rem;
            margin-bottom: 10px;
        }

        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .action-btn {
            background: #1a1a1a;
            border: 1px solid #252525;
            color: #ccc;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.7rem;
            text-align: center;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: #252525;
            border-color: #00d4aa;
            color: #fff;
        }

        .action-btn .icon {
            font-size: 1rem;
            display: block;
            margin-bottom: 3px;
        }

        /* Scrollbar */
        .panel-content::-webkit-scrollbar,
        .sidebar::-webkit-scrollbar {
            width: 5px;
        }

        .panel-content::-webkit-scrollbar-track,
        .sidebar::-webkit-scrollbar-track {
            background: #0d0d0d;
        }

        .panel-content::-webkit-scrollbar-thumb,
        .sidebar::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 3px;
        }

        .panel-content::-webkit-scrollbar-thumb:hover,
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #00d4aa;
            color: #0d0d0d;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            box-shadow: 0 4px 20px rgba(0, 212, 170, 0.2);
            transition: transform 0.3s ease;
            z-index: 10000;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Setup Modal */
        .setup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 10001;
            display: none;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            padding: 20px;
        }
        .setup-modal.show {
            display: flex;
        }
        .setup-content {
            background: #141414;
            border-radius: 16px;
            padding: 24px;
            max-width: 800px;
            width: 95%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border: 1px solid #252525;
            max-height: 95vh;
            overflow-y: auto;
        }
        .setup-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid #252525;
        }
        .setup-content h2 {
            color: #fff;
            margin-bottom: 4px;
            font-size: 1.3rem;
        }
        .setup-content > p, .setup-header p {
            color: #888;
            font-size: 0.8rem;
            margin: 0;
        }
        .setup-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .setup-column {
            display: flex;
            flex-direction: column;
        }
        .setup-column-title {
            color: #00d4aa;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #252525;
        }
        .setup-field {
            margin-bottom: 14px;
        }
        .setup-field label {
            display: block;
            color: #ccc;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 4px;
        }
        .setup-field input, .setup-field textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #252525;
            border-radius: 6px;
            background: #0d0d0d;
            color: #fff;
            font-size: 0.8rem;
            font-family: 'Monaco', 'Menlo', monospace;
            transition: border-color 0.2s;
        }
        .setup-field input:focus, .setup-field textarea:focus {
            outline: none;
            border-color: #00d4aa;
        }
        .setup-field input::placeholder, .setup-field textarea::placeholder {
            color: #555;
        }
        .setup-field small {
            display: block;
            color: #666;
            font-size: 0.65rem;
            margin-top: 3px;
        }
        .setup-footer {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid #252525;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            align-items: start;
        }
        .setup-actions {
            display: flex;
            gap: 10px;
        }
        .setup-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .setup-btn.primary {
            background: #00d4aa;
            color: #0d0d0d;
        }
        .setup-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 170, 0.3);
            background: #00b894;
        }
        .setup-btn.secondary {
            background: #252525;
            color: #888;
            border: 1px solid #333;
        }
        .setup-btn.secondary:hover {
            background: #333;
            color: #fff;
        }
        .setup-help {
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid #252525;
            text-align: center;
        }
        .setup-help p {
            color: #666;
            font-size: 0.75rem;
            margin: 4px 0;
        }
        .setup-help code {
            display: inline-block;
            background: #0d0d0d;
            color: #7dd3c0;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            margin-top: 8px;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .main-layout {
                grid-template-columns: 200px 1fr 1fr 1fr;
                margin-right: 22%;
            }
            .nav-btn span:first-child {
                display: none;
            }
        }

        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 180px 1fr 1fr;
                grid-template-rows: auto auto auto auto;
                margin-right: 20%;
            }
            .sidebar {
                grid-row: 1 / 3;
            }
            .top-nav {
                right: 20%;
            }
        }

        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr;
                margin-right: 0;
                margin-top: 50px;
            }
            .top-nav {
                right: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Top Navigation Bar -->
    <nav class="top-nav">
        <div class="nav-brand">
            <h1>WidgetScope</h1>
            <span class="badge" id="orgBadgeNav">Debug Mode</span>
            <!-- Mini Status Orb in Nav -->
            <div class="nav-status-orb" id="navStatusOrb" onclick="statusOrb.showDetails()" title="System Status">
                <div class="nav-orb-core" id="statusOrbCore"></div>
                <div class="nav-orb-ring" id="statusOrbRing1"></div>
            </div>
            <span class="nav-status-text" id="statusOrbText">Initializing</span>
        </div>
        <div class="nav-actions">
            <button class="nav-btn" onclick="debugTools.inspectWidget()">
                <span>&#128269;</span> Inspect
            </button>
            <button class="nav-btn" onclick="debugTools.checkConnectivity()">
                <span>&#128225;</span> Ping
            </button>
            <button class="nav-btn primary" onclick="debugTools.copyFullReport()">
                <span>&#128203;</span> Full Report
            </button>
            <button class="nav-btn" onclick="debugTools.copyWidgetConfig()">
                <span>&#9881;</span> Config
            </button>
            <div class="nav-divider"></div>
            <button class="nav-btn" onclick="debugTools.reloadWidget()">
                <span>&#8635;</span> Reload
            </button>
            <button class="nav-btn danger" onclick="debugTools.clearAllLogs()">
                <span>&#128465;</span> Clear
            </button>
            <button class="nav-btn" onclick="debugTools.exportLogs()">
                <span>&#128190;</span> Export
            </button>
            <div class="nav-divider"></div>
            <button class="nav-btn" onclick="showSetupModal()">
                <span>&#9881;</span> Configure
            </button>
            <button class="help-btn" onclick="helpPanel.toggle()">
                <span>&#128218;</span> Docs
            </button>
        </div>
    </nav>

    <!-- Help Panel Overlay -->
    <div class="help-overlay" id="helpOverlay" onclick="helpPanel.close()"></div>

    <!-- Help Panel -->
    <div class="help-panel" id="helpPanel">
        <button class="help-close" onclick="helpPanel.close()">&times;</button>

        <!-- Navigation -->
        <nav class="help-nav">
            <div class="help-nav-header">
                <h2>Debug Dashboard</h2>
                <p>Documentation & Help</p>
            </div>

            <div class="help-nav-section">Getting Started</div>
            <div class="help-nav-item active" data-section="overview">Overview</div>
            <div class="help-nav-item" data-section="dashboard-tools">Dashboard Tools</div>

            <div class="help-nav-section">Webex Connect</div>
            <div class="help-nav-item" data-section="widget-sdk">Widget SDK Methods</div>
            <div class="help-nav-item" data-section="widget-config">Widget Configuration</div>
            <div class="help-nav-item" data-section="troubleshooting">Troubleshooting</div>

            <div class="help-nav-section">Developer Reference</div>
            <div class="help-nav-item" data-section="postmessage-api">PostMessage API</div>
            <div class="help-nav-item" data-section="common-issues">Common Issues</div>
            <div class="help-nav-item" data-section="resources">External Resources</div>
        </nav>

        <!-- Content -->
        <div class="help-content">
            <!-- Overview Section -->
            <div class="help-section active" id="section-overview">
                <h2>Debug Dashboard Overview</h2>
                <p>This dashboard provides real-time debugging and monitoring tools for Webex Connect (IMI Chat) chatbot widgets. Use it to inspect widget communication, troubleshoot issues, and understand how your chatbot interacts with web pages.</p>

                <h3>Dashboard Layout</h3>
                <p>The dashboard is organized into four main areas:</p>
                <ul>
                    <li><strong>Left Sidebar</strong> - Widget status, session info, filters, and widget configuration details</li>
                    <li><strong>Console Logs</strong> - Captures all JavaScript console output from the page</li>
                    <li><strong>PostMessages</strong> - Shows cross-origin communication between the widget iframe and parent page</li>
                    <li><strong>Network &amp; Events</strong> - Tracks HTTP requests and widget lifecycle events</li>
                </ul>

                <div class="help-tip">
                    <p><strong>Tip:</strong> The right 25% of the screen is reserved for the chatbot widget. You can interact with the chatbot while viewing debug information.</p>
                </div>

                <h3>Quick Start</h3>
                <ol>
                    <li>Open this page - the widget loads automatically</li>
                    <li>Watch the <strong>PostMessages</strong> panel for widget initialization</li>
                    <li>Look for <code>loadstyles</code> action to confirm config received</li>
                    <li>Use <strong>Full Report</strong> to export all debug data</li>
                </ol>
            </div>

            <!-- Dashboard Tools Section -->
            <div class="help-section" id="section-dashboard-tools">
                <h2>Dashboard Tools</h2>
                <p>Each panel and button in the dashboard serves a specific debugging purpose.</p>

                <h3>Sidebar Controls</h3>

                <div class="tool-card">
                    <h4><span>&#8635;</span> Reload Widget</h4>
                    <p>Removes the current widget instance and reinitializes it. Useful for testing initialization sequences or recovering from errors. Clears the widget iframe and reloads the IMI Chat script.</p>
                </div>

                <div class="tool-card">
                    <h4><span>&#128465;</span> Clear</h4>
                    <p>Clears all logged data from every panel. Use this to start fresh when debugging a specific interaction sequence.</p>
                </div>

                <div class="tool-card">
                    <h4><span>&#128190;</span> Export</h4>
                    <p>Downloads all captured logs as a JSON file. The export includes session info, widget config, and all panel data with timestamps.</p>
                </div>

                <h3>Quick Actions</h3>

                <div class="tool-card">
                    <h4><span>&#128269;</span> Inspect</h4>
                    <p>Logs current widget state to the Events panel. Shows: DOM presence of widget elements, iframe count, IMI objects, and whether config has been received.</p>
                </div>

                <div class="tool-card">
                    <h4><span>&#128225;</span> Ping</h4>
                    <p>Tests connectivity to IMI servers by sending a HEAD request to <code>media.imi.chat</code>. Reports latency in milliseconds or connection failure.</p>
                </div>

                <div class="tool-card">
                    <h4><span>&#128203;</span> Full Report</h4>
                    <p>Copies a comprehensive JSON report to clipboard. Includes environment info, widget config, and <strong>filtered logs</strong> (noise removed). Perfect for sharing with support teams.</p>
                </div>

                <div class="tool-card">
                    <h4><span>&#9881;</span> Copy Config</h4>
                    <p>Copies just the widget configuration JSON. Only available after the <code>loadstyles</code> PostMessage is received.</p>
                </div>

                <h3>Filter Controls</h3>
                <p>Located in the sidebar, these checkboxes control what appears in the PostMessages panel:</p>
                <ul>
                    <li><strong>Hide React DevTools noise</strong> - Filters out browser extension messages</li>
                    <li><strong>Hide debug_panel test msgs</strong> - Filters dashboard's own test messages</li>
                    <li><strong>Collapse repeated messages</strong> - Groups identical consecutive messages with a count badge</li>
                </ul>

                <h3>Panel Features</h3>
                <p>Each debug panel includes:</p>
                <ul>
                    <li><strong>Counter badge</strong> - Shows number of logged entries</li>
                    <li><strong>Copy button</strong> - Copies all panel entries as JSON</li>
                    <li><strong>Per-entry copy</strong> - Hover over any entry to reveal its copy button</li>
                    <li><strong>Color coding</strong> - Boolean values show green (true) or red (false)</li>
                    <li><strong>Source tags</strong> - WIDGET, BROWSER, or DEBUG labels on PostMessages</li>
                </ul>
            </div>

            <!-- Widget SDK Methods Section -->
            <div class="help-section" id="section-widget-sdk">
                <h2>IMI Chat Widget SDK Methods</h2>
                <p>The Webex Engage LiveChat widget exposes JavaScript SDK methods to control its behavior. These methods are available on the global <code>imichatwidget</code> object.</p>

                <h3>imichatwidget.show()</h3>
                <p>Displays the chat widget. Use this when you've hidden the widget by default and want to show it programmatically (e.g., on button click).</p>
                <pre><code>// Show the widget when user clicks a button
document.getElementById('chatBtn').onclick = function() {
    imichatwidget.show();
};</code></pre>

                <h3>imichatwidget.hide()</h3>
                <p>Hides the chat widget from view. The widget remains loaded but invisible.</p>
                <pre><code>imichatwidget.hide();</code></pre>

                <h3>imichatwidget.init(data, callback)</h3>
                <p>Initializes the widget with custom data. Pass custom chat fields that will be attached to all conversations.</p>
                <pre><code>var data = JSON.stringify({
    "custom_chat_fields": {
        "Customer ID": "12345",
        "Plan Type": "Premium"
    }
});

imichatwidget.init(data, function(response) {
    console.log('Widget initialized', response);
});</code></pre>

                <div class="help-warning">
                    <p><strong>Note:</strong> Custom field keys must be configured in the Webex Engage Admin Console before use. Unknown keys are silently ignored.</p>
                </div>

                <h3>imichatwidget.update(data, callback)</h3>
                <p>Updates custom chat fields after initialization. Behaves similarly to <code>init()</code>.</p>
                <pre><code>var data = JSON.stringify({
    "custom_chat_fields": {
        "Page": "checkout",
        "Cart Value": "$150"
    }
});

imichatwidget.update(data, function(response) {
    console.log('Fields updated');
});</code></pre>

                <h3>imichatwidget.on(event, callback)</h3>
                <p>Subscribe to widget events. The most common event is <code>imichat-widget:ready</code>.</p>
                <pre><code>imichatwidget.on("imichat-widget:ready", function(appId) {
    console.log('Widget ready, App ID:', appId);
    // Safe to call other methods now
    imichatwidget.show();
    imichatwidget.maximizeWindow();
});</code></pre>

                <h3>imichatwidget.maximizeWindow()</h3>
                <p>Expands the chat widget to its maximized state (full chat view).</p>

                <h3>imichatwidget.minimizeWindow()</h3>
                <p>Minimizes the chat widget to its collapsed state (just the launcher button).</p>

                <h3>Complete Example</h3>
                <pre><code>&lt;!-- Widget container (hidden by default) --&gt;
&lt;div id="divicw"
     data-bind="YOUR-BIND-ID"
     data-guid="YOUR-GUID"
     style="display:none;"&gt;&lt;/div&gt;

&lt;!-- Custom chat button --&gt;
&lt;button id="openChat"&gt;Need Help?&lt;/button&gt;

&lt;script&gt;
// Wait for widget to be ready
imichatwidget.on("imichat-widget:ready", function(appId) {
    // Initialize with customer data
    var customerData = JSON.stringify({
        "custom_chat_fields": {
            "User ID": getUserId(),
            "Page": window.location.pathname
        }
    });

    imichatwidget.init(customerData, function() {
        // Enable the chat button
        document.getElementById('openChat').disabled = false;
    });
});

// Open chat on button click
document.getElementById('openChat').onclick = function() {
    imichatwidget.show();
    imichatwidget.maximizeWindow();
};
&lt;/script&gt;

&lt;!-- Load widget script --&gt;
&lt;script src="https://media.imi.chat/widget/js/imichatinit.js"&gt;&lt;/script&gt;</code></pre>
            </div>

            <!-- Widget Configuration Section -->
            <div class="help-section" id="section-widget-config">
                <h2>Widget Configuration</h2>
                <p>Widget configuration is received via PostMessage with the <code>loadstyles</code> action. This dashboard parses and displays key settings in the sidebar.</p>

                <h3>Configuration Fields</h3>
                <table class="config-table">
                    <tr>
                        <th>Field</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><code>appid</code></td>
                        <td>Unique application identifier for this widget instance</td>
                    </tr>
                    <tr>
                        <td><code>name</code></td>
                        <td>Display name configured for the widget</td>
                    </tr>
                    <tr>
                        <td><code>website_id</code></td>
                        <td>ID of the website this widget is registered for</td>
                    </tr>
                    <tr>
                        <td><code>agent_avail</code></td>
                        <td>Whether live agents are currently available (1 = yes, 0 = no)</td>
                    </tr>
                    <tr>
                        <td><code>enable_proactive</code></td>
                        <td>Whether proactive chat invitations are enabled</td>
                    </tr>
                    <tr>
                        <td><code>isattachmentenabled</code></td>
                        <td>Whether file attachments are allowed in chat</td>
                    </tr>
                    <tr>
                        <td><code>isemojienable</code></td>
                        <td>Whether emoji picker is available</td>
                    </tr>
                    <tr>
                        <td><code>widget_lang</code></td>
                        <td>Language code for widget UI text</td>
                    </tr>
                    <tr>
                        <td><code>widgetcolor</code></td>
                        <td>Primary color theme (hex code)</td>
                    </tr>
                </table>

                <h3>Installation Requirements</h3>
                <p>To install the widget on your website:</p>
                <ol>
                    <li>Obtain your widget credentials from Webex Engage Admin Console</li>
                    <li>Add the widget container div with your <code>data-bind</code> and <code>data-guid</code> values</li>
                    <li>Include the IMI Chat initialization script</li>
                    <li>Whitelist your domain in the Admin Console (without http/https prefix)</li>
                </ol>

                <pre><code>&lt;!-- Widget container --&gt;
&lt;div id="divicw"
     data-bind="YOUR-BIND-ID"
     data-guid="YOUR-WIDGET-GUID"&gt;&lt;/div&gt;

&lt;!-- Widget script (add before closing body tag) --&gt;
&lt;script src="https://media.imi.chat/widget/js/imichatinit.js"&gt;&lt;/script&gt;</code></pre>

                <h3>Domain Whitelisting</h3>
                <p>Configure your domain in General Settings using patterns like:</p>
                <ul>
                    <li><code>*.example.com</code> - All subdomains</li>
                    <li><code>www.example.com</code> - Specific subdomain</li>
                    <li><code>example.com</code> - Root domain only</li>
                </ul>
                <div class="help-warning">
                    <p><strong>Important:</strong> Do not include http:// or https:// in the domain configuration.</p>
                </div>

                <h3>24/7 Availability</h3>
                <p>To make the widget available outside business hours:</p>
                <ol>
                    <li>Go to Admin Console &gt; LiveChat Channel settings</li>
                    <li>Enable "Suppress working hours and agent presence checks"</li>
                    <li>The widget will now be available regardless of agent availability</li>
                </ol>
            </div>

            <!-- Troubleshooting Section -->
            <div class="help-section" id="section-troubleshooting">
                <h2>Troubleshooting Guide</h2>
                <p>Common issues and their solutions when working with the Webex Connect widget.</p>

                <h3>Widget Not Appearing</h3>
                <h4>Check the Console Logs panel for errors</h4>
                <ul>
                    <li><strong>404 on imichatinit.js</strong> - Verify the script URL is correct and accessible</li>
                    <li><strong>CORS errors</strong> - Your domain may not be whitelisted in Admin Console</li>
                    <li><strong>No errors but no widget</strong> - Check if <code>divicw</code> element exists with correct attributes</li>
                </ul>

                <h4>Check the PostMessages panel</h4>
                <ul>
                    <li><strong>No messages from imi.chat</strong> - Script may not have loaded successfully</li>
                    <li><strong>loadstyles not received</strong> - Widget failed to initialize; check GUID and bind ID</li>
                </ul>

                <div class="help-tip">
                    <p><strong>Tip:</strong> Use the Ping button to verify connectivity to IMI servers.</p>
                </div>

                <h3>Widget Loads But Chat Fails</h3>
                <ul>
                    <li><strong>agent_avail = 0</strong> - No agents are online; check team schedules</li>
                    <li><strong>Connection timeout</strong> - Check Network panel for failed WebSocket connections</li>
                    <li><strong>Blank chat window</strong> - May indicate bot configuration issue; check Webex Connect flows</li>
                </ul>

                <h3>Custom Fields Not Working</h3>
                <ul>
                    <li>Verify field names match exactly (case-sensitive) with Admin Console configuration</li>
                    <li>Call <code>init()</code> or <code>update()</code> after <code>imichat-widget:ready</code> event</li>
                    <li>Ensure data is properly JSON stringified</li>
                </ul>

                <h3>Performance Issues</h3>
                <ul>
                    <li><strong>Slow load</strong> - Add cache-busting parameter sparingly; remove for production</li>
                    <li><strong>Memory issues</strong> - Avoid repeatedly calling init without page refresh</li>
                    <li><strong>Duplicate widgets</strong> - Check for multiple script inclusions</li>
                </ul>

                <h3>Debug Checklist</h3>
                <ol>
                    <li>Is <code>divicw</code> present with correct <code>data-bind</code> and <code>data-guid</code>?</li>
                    <li>Is the script tag loading from <code>media.imi.chat</code>?</li>
                    <li>Does the domain match whitelist configuration?</li>
                    <li>Are there any JavaScript errors in console?</li>
                    <li>Is <code>loadstyles</code> PostMessage received?</li>
                    <li>What does <code>agent_avail</code> show in config?</li>
                    <li>Can you ping the IMI servers successfully?</li>
                </ol>
            </div>

            <!-- PostMessage API Section -->
            <div class="help-section" id="section-postmessage-api">
                <h2>PostMessage Communication</h2>
                <p>The widget communicates with the parent page using the browser's <code>postMessage</code> API. This dashboard intercepts and displays these messages for debugging.</p>

                <h3>Message Structure</h3>
                <p>Widget messages typically contain:</p>
                <pre><code>{
    "action": "actionName",
    "message": "...",
    "key": "...",
    "value": "..."
}</code></pre>

                <h3>Common Actions</h3>
                <table class="config-table">
                    <tr>
                        <th>Action</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td><code>loadstyles</code></td>
                        <td>Widget configuration payload (JSON in message field)</td>
                    </tr>
                    <tr>
                        <td><code>setlocal</code></td>
                        <td>Widget storing data in localStorage (key/value)</td>
                    </tr>
                    <tr>
                        <td><code>getlocal</code></td>
                        <td>Widget retrieving data from localStorage</td>
                    </tr>
                    <tr>
                        <td><code>resize</code></td>
                        <td>Widget requesting size change</td>
                    </tr>
                    <tr>
                        <td><code>maximize</code></td>
                        <td>Widget expanding to full view</td>
                    </tr>
                    <tr>
                        <td><code>minimize</code></td>
                        <td>Widget collapsing to launcher</td>
                    </tr>
                </table>

                <h3>Message Origins</h3>
                <p>Messages come from different sources:</p>
                <ul>
                    <li><strong>media.imi.chat</strong> - Official widget messages (tagged as WIDGET)</li>
                    <li><strong>Browser extensions</strong> - React DevTools, Redux tools, etc. (tagged as BROWSER)</li>
                    <li><strong>Same origin</strong> - Your own page or this debug panel (tagged as DEBUG)</li>
                </ul>

                <h3>Fingerprint Tracking</h3>
                <p>The widget generates a unique fingerprint for visitor tracking. Look for <code>setlocal</code> action with <code>key: "fingerprint"</code> to see this value. It's used to maintain conversation continuity across sessions.</p>

                <h3>Filtering Noise</h3>
                <p>Browser extensions often flood postMessage with their own communications. This dashboard automatically filters:</p>
                <ul>
                    <li>React DevTools "hello" messages</li>
                    <li>Redux DevTools communications</li>
                    <li>Messages from chrome-extension:// or moz-extension://</li>
                </ul>
                <p>Toggle filters in the sidebar to show or hide these messages.</p>
            </div>

            <!-- Common Issues Section -->
            <div class="help-section" id="section-common-issues">
                <h2>Common Issues Reference</h2>

                <h3>Error: Widget GUID Not Found</h3>
                <p><strong>Cause:</strong> The <code>data-guid</code> attribute doesn't match any registered widget.</p>
                <p><strong>Solution:</strong> Verify the GUID in Webex Engage Admin Console under LiveChat assets.</p>

                <h3>Error: Domain Not Whitelisted</h3>
                <p><strong>Cause:</strong> The current page's domain isn't in the allowed list.</p>
                <p><strong>Solution:</strong> Add your domain pattern to the widget's allowed domains in Admin Console.</p>

                <h3>Error: Cross-Origin Frame Access Denied</h3>
                <p><strong>Cause:</strong> Normal security behavior - you cannot directly access iframe content.</p>
                <p><strong>Solution:</strong> This is expected. Use PostMessage API for communication.</p>

                <h3>Warning: IMIchat is undefined</h3>
                <p><strong>Cause:</strong> Trying to call widget methods before script loads.</p>
                <p><strong>Solution:</strong> Wait for <code>imichat-widget:ready</code> event before calling methods.</p>

                <h3>Issue: Chat History Not Showing</h3>
                <p><strong>Cause:</strong> Conversation history may be disabled or fingerprint changed.</p>
                <p><strong>Solution:</strong> Check Admin Console settings and verify localStorage isn't being cleared.</p>

                <h3>Issue: Bot Not Responding</h3>
                <p><strong>Possible causes:</strong></p>
                <ul>
                    <li>Flow not published in Webex Connect</li>
                    <li>Bot integration webhook URL incorrect</li>
                    <li>Error in bot flow logic</li>
                    <li>Service account permissions</li>
                </ul>
                <p><strong>Debug:</strong> Check Webex Connect flow debugger and webhook logs.</p>
            </div>

            <!-- Resources Section -->
            <div class="help-section" id="section-resources">
                <h2>External Resources</h2>

                <div style="margin-bottom: 20px;">
                    <button class="setup-btn primary" onclick="helpPanel.exportDocs()" style="width: auto; padding: 10px 20px;">
                        <span>&#128190;</span> Export All Documentation
                    </button>
                    <p style="margin-top: 8px; font-size: 0.75rem; color: #888;">Downloads complete documentation as a markdown file</p>
                </div>

                <p>Official documentation and community resources for Webex Connect development.</p>

                <h3>Official Documentation</h3>
                <ul>
                    <li><a href="https://docs.imi.chat/reference/introduction" target="_blank" class="help-link">Webex Engage Developer Guide</a> - API reference and SDK methods</li>
                    <li><a href="https://docs.imi.chat/docs/livechat-channel" target="_blank" class="help-link">LiveChat Channel Setup</a> - Configuration guide</li>
                    <li><a href="https://developer.webex.com/docs/webex-connect" target="_blank" class="help-link">Webex Connect Overview</a> - Platform documentation</li>
                    <li><a href="https://developers.imiconnect.io/" target="_blank" class="help-link">IMI Connect API Docs</a> - Complete API reference</li>
                    <li><a href="https://help.webexconnect.io/docs/livechat" target="_blank" class="help-link">LiveChat Platform Guide</a> - Webex Connect platform docs</li>
                </ul>

                <h3>SDK Reference Pages</h3>
                <ul>
                    <li><a href="https://docs.imi.chat/reference/imichatwidgetshow" target="_blank" class="help-link">imichatwidget.show()</a></li>
                    <li><a href="https://docs.imi.chat/reference/imichatwidgetinit" target="_blank" class="help-link">imichatwidget.init()</a></li>
                    <li><a href="https://docs.imi.chat/reference/imichatwidgetupdate" target="_blank" class="help-link">imichatwidget.update()</a></li>
                    <li><a href="https://docs.imi.chat/reference/imichatwidgetonimichat-widgetready-func" target="_blank" class="help-link">imichatwidget.on()</a></li>
                </ul>

                <h3>Community &amp; Support</h3>
                <ul>
                    <li><a href="https://community.cisco.com/t5/webex-connect/bd-p/connect" target="_blank" class="help-link">Cisco Community Forum</a> - Developer community Q&amp;A</li>
                    <li><a href="https://developer.webex.com/explore/docs/api/guides/troubleshooting" target="_blank" class="help-link">Webex Troubleshooting Guide</a></li>
                </ul>

                <h3>Testing Tools</h3>
                <ul>
                    <li><a href="https://glitch.com" target="_blank" class="help-link">Glitch.com</a> - Recommended for testing widgets without a live site</li>
                </ul>

                <div class="help-tip">
                    <p><strong>Need help?</strong> Contact your customer success representative or email <a href="mailto:developers@webex.com" class="help-link">developers@webex.com</a></p>
                </div>
            </div>
        </div>
    </div>

    <div class="main-layout">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <div class="container">
                <span class="badge" id="orgBadge">Your Organization</span>

                <div class="status-card">
                    <div class="status-indicator">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="statusText">Initializing...</span>
                    </div>
                </div>

                <div class="state-grid">
                    <div class="state-item">
                        <div class="state-label">Widget</div>
                        <div class="state-value pending" id="widgetState">Loading</div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Script</div>
                        <div class="state-value pending" id="scriptState">Pending</div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Network</div>
                        <div class="state-value" id="networkCount">0</div>
                    </div>
                    <div class="state-item">
                        <div class="state-label">Widget Msgs</div>
                        <div class="state-value" id="messageCount">0</div>
                    </div>
                </div>
            </div>

            <!-- Filter Controls -->
            <div class="config-panel">
                <h3><span>&#128295;</span> Filters</h3>
                <div class="filter-toggle">
                    <input type="checkbox" id="filterDevtools" checked onchange="debugTools.toggleFilter('devtools')">
                    <label for="filterDevtools">Hide React DevTools noise</label>
                </div>
                <div class="filter-toggle" style="margin-top: 6px;">
                    <input type="checkbox" id="filterDebugPanel" onchange="debugTools.toggleFilter('debugPanel')">
                    <label for="filterDebugPanel">Hide debug_panel test msgs</label>
                </div>
                <div class="filter-toggle" style="margin-top: 6px;">
                    <input type="checkbox" id="collapseRepeats" checked onchange="debugTools.toggleFilter('collapse')">
                    <label for="collapseRepeats">Collapse repeated messages</label>
                </div>
                <div class="filter-stats" id="filterStats">Filtered: 0 | Shown: 0</div>
            </div>

            <!-- Widget Config Panel -->
            <div class="config-panel">
                <h3><span>&#9881;</span> Widget Config</h3>
                <div id="widgetConfigContent">
                    <div class="config-item">
                        <span class="config-label">Status</span>
                        <span class="config-value warning">Waiting...</span>
                    </div>
                </div>
            </div>

            <!-- Session Panel -->
            <div class="config-panel">
                <h3><span>&#128273;</span> Session</h3>
                <div class="config-item">
                    <span class="config-label">ID</span>
                    <span class="config-value" id="sessionId">-</span>
                </div>
                <div class="config-item">
                    <span class="config-label">Started</span>
                    <span class="config-value" id="sessionStart">-</span>
                </div>
                <div class="config-item">
                    <span class="config-label">Duration</span>
                    <span class="config-value" id="sessionDuration">0s</span>
                </div>
                <div class="config-item">
                    <span class="config-label">Fingerprint</span>
                    <span class="config-value" id="fingerprint">-</span>
                </div>
            </div>

            <!-- Page Visibility -->
            <div class="config-panel collapsible collapsed" id="visibilityPanel">
                <h3 class="section-header" onclick="safariDebug.toggleSection('visibility')">
                    <span class="section-icon">&#128065;</span>
                    <span>Visibility</span>
                    <span class="section-status" id="visStatusDot"></span>
                    <span class="section-toggle">&#9660;</span>
                </h3>
                <div class="section-summary" id="visibilitySummary">
                    <span class="metric-badge visible" id="visStateBadge">Visible</span>
                </div>
                <div class="section-content" id="visibilityContent">
                    <div class="config-item">
                        <span class="config-label">State</span>
                        <span class="config-value" id="visCurrentState">visible</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Time Visible</span>
                        <span class="config-value" id="visTimeVisible">0s</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Time Hidden</span>
                        <span class="config-value" id="visTimeHidden">0s</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Transitions</span>
                        <span class="config-value" id="visTransitions">0</span>
                    </div>
                    <div class="mini-log" id="visLogContainer"></div>
                </div>
            </div>

            <!-- Browser Detection -->
            <div class="config-panel collapsible collapsed" id="browserPanel">
                <h3 class="section-header" onclick="safariDebug.toggleSection('browser')">
                    <span class="section-icon">&#127758;</span>
                    <span>Browser</span>
                    <span class="section-status" id="browserStatusDot"></span>
                    <span class="section-toggle">&#9660;</span>
                </h3>
                <div class="section-summary" id="browserSummary">
                    <span class="metric-badge" id="browserBadge">Detecting...</span>
                </div>
                <div class="section-content" id="browserContent">
                    <div class="config-item">
                        <span class="config-label">Browser</span>
                        <span class="config-value" id="browserDetected">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Version</span>
                        <span class="config-value" id="browserVersion">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Platform</span>
                        <span class="config-value" id="browserPlatform">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">iOS</span>
                        <span class="config-value" id="iosVersion">N/A</span>
                    </div>
                    <div class="config-item" id="webkitBugWarning" style="display: none;">
                        <span class="config-label">Warning</span>
                        <span class="config-value warning">WebKit #247943</span>
                    </div>
                    <div class="config-item" id="itpWarning" style="display: none;">
                        <span class="config-label">ITP</span>
                        <span class="config-value warning">Iframe Restricted</span>
                    </div>
                </div>
            </div>

            <!-- Network Status -->
            <div class="config-panel collapsible collapsed" id="networkStatusPanel">
                <h3 class="section-header" onclick="safariDebug.toggleSection('networkStatus')">
                    <span class="section-icon">&#128225;</span>
                    <span>Network</span>
                    <span class="section-status" id="netStatusDot"></span>
                    <span class="section-toggle">&#9660;</span>
                </h3>
                <div class="section-summary" id="networkSummary">
                    <span class="metric-badge online" id="netStateBadge">Online</span>
                </div>
                <div class="section-content" id="networkContent">
                    <div class="config-item">
                        <span class="config-label">Status</span>
                        <span class="config-value online" id="netCurrentStatus">Online</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Type</span>
                        <span class="config-value" id="netConnectionType">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Effective</span>
                        <span class="config-value" id="netEffectiveType">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Transitions</span>
                        <span class="config-value" id="netTransitions">0</span>
                    </div>
                    <div class="mini-log" id="netLogContainer"></div>
                </div>
            </div>

            <!-- Storage Diagnostics -->
            <div class="config-panel collapsible collapsed" id="storagePanel">
                <h3 class="section-header" onclick="safariDebug.toggleSection('storage')">
                    <span class="section-icon">&#128451;</span>
                    <span>Storage</span>
                    <span class="section-status" id="storageStatusDot"></span>
                    <span class="section-toggle">&#9660;</span>
                </h3>
                <div class="section-summary" id="storageSummary">
                    <span class="metric-badge" id="storageBadge">Checking...</span>
                </div>
                <div class="section-content" id="storageContent">
                    <div class="config-item">
                        <span class="config-label">localStorage</span>
                        <span class="config-value" id="localStorageStatus">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">sessionStorage</span>
                        <span class="config-value" id="sessionStorageStatus">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Cookies</span>
                        <span class="config-value" id="cookieStatus">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">IndexedDB</span>
                        <span class="config-value" id="indexedDBStatus">-</span>
                    </div>
                    <div class="config-item">
                        <span class="config-label">Context</span>
                        <span class="config-value" id="storageContext">-</span>
                    </div>
                    <button class="control-btn secondary" onclick="safariDebug.runStorageTest()" style="margin-top: 8px; width: 100%; font-size: 0.65rem;">
                        &#128269; Re-test Storage
                    </button>
                </div>
            </div>

        </div>

        <!-- Column 2 - Console Logs (top) -->
        <div class="debug-panel">
            <div class="panel-header">
                <span class="panel-title"><span>&#128221;</span> Console Logs</span>
                <div class="panel-actions">
                    <span class="panel-count" id="consoleCount">0</span>
                    <button class="copy-btn" onclick="debugTools.copyPanelLogs('console')">
                        <span>&#128203;</span> Copy
                    </button>
                </div>
            </div>
            <div class="panel-content" id="consoleLogs"></div>
        </div>

        <!-- Column 3 - PostMessages (top) -->
        <div class="debug-panel">
            <div class="panel-header">
                <span class="panel-title"><span>&#128233;</span> PostMessages</span>
                <div class="panel-actions">
                    <span class="panel-count" id="postMessageCount">0</span>
                    <span class="panel-count filtered" id="postMessageFiltered" style="display:none;">0 hidden</span>
                    <button class="copy-btn" onclick="debugTools.copyPanelLogs('postMessage')">
                        <span>&#128203;</span> Copy
                    </button>
                </div>
            </div>
            <div class="panel-content" id="postMessageLogs"></div>
        </div>

        <!-- Column 4 - WebSocket & MQTT Split Panel (spans both rows) -->
        <div class="ws-mqtt-split">
            <!-- WebSocket Monitor -->
            <div class="split-panel" id="wsMonitorPanel">
                <div class="panel-header">
                    <span class="panel-title">
                        <span>&#128268;</span> WebSocket
                        <span class="section-status" id="wsStatusDot"></span>
                    </span>
                    <div class="panel-actions">
                        <span class="panel-count" id="wsConnBadge">0</span>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="metric-row">
                        <span class="metric-label">Active</span>
                        <span class="metric-value" id="wsActiveCount">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Total</span>
                        <span class="metric-value" id="wsTotalOpened">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Sent</span>
                        <span class="metric-value" id="wsMsgsSent">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Received</span>
                        <span class="metric-value" id="wsMsgsReceived">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Zombies</span>
                        <span class="metric-value warning" id="wsZombieCount">0</span>
                    </div>
                    <div class="mini-log" id="wsLogContainer"></div>
                </div>
            </div>

            <!-- MQTT Monitor -->
            <div class="split-panel" id="mqttPanel">
                <div class="panel-header">
                    <span class="panel-title">
                        <span>&#128225;</span> MQTT
                        <span class="section-status" id="mqttStatusDot"></span>
                    </span>
                    <div class="panel-actions">
                        <span class="panel-count" id="mqttConnBadge">-</span>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="mqtt-connection-indicator disconnected" id="mqttConnIndicator">
                        <span>&#9679;</span> <span id="mqttConnState">Not detected</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Connections</span>
                        <span class="metric-value" id="mqttConnCount">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Published</span>
                        <span class="metric-value" id="mqttPubCount">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Received</span>
                        <span class="metric-value" id="mqttRecvCount">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Subscribes</span>
                        <span class="metric-value" id="mqttSubCount">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Pings</span>
                        <span class="metric-value" id="mqttPingCount">0</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Broker</span>
                        <span class="metric-value" id="mqttBrokerUrl" style="font-size: 0.55rem; word-break: break-all;">-</span>
                    </div>
                    <div class="mini-log" id="mqttLogContainer"></div>
                </div>
            </div>
        </div>

        <!-- Column 2 - Network (bottom) -->
        <div class="debug-panel">
            <div class="panel-header">
                <span class="panel-title"><span>&#127760;</span> Network</span>
                <div class="panel-actions">
                    <span class="panel-count" id="networkLogCount">0</span>
                    <button class="copy-btn" onclick="debugTools.copyPanelLogs('network')">
                        <span>&#128203;</span> Copy
                    </button>
                </div>
            </div>
            <div class="panel-content" id="networkLogs"></div>
        </div>

        <!-- Column 3 - Widget Events (bottom) -->
        <div class="debug-panel">
            <div class="panel-header">
                <span class="panel-title"><span>&#9889;</span> Widget Events</span>
                <div class="panel-actions">
                    <span class="panel-count" id="eventCount">0</span>
                    <button class="copy-btn" onclick="debugTools.copyPanelLogs('events')">
                        <span>&#128203;</span> Copy
                    </button>
                </div>
            </div>
            <div class="panel-content" id="eventLogs"></div>
        </div>

        <!-- Column 4 - Browser Console (bottom) -->
        <div class="debug-panel">
            <div class="panel-header">
                <span class="panel-title"><span>&#128187;</span> Browser Console</span>
                <div class="panel-actions">
                    <span class="panel-count" id="browserConsoleCount">0</span>
                    <button class="copy-btn" onclick="debugTools.copyPanelLogs('browserConsole')">
                        <span>&#128203;</span> Copy
                    </button>
                </div>
            </div>
            <div class="panel-content" id="browserConsoleLogs"></div>
        </div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast">Copied to clipboard!</div>

    <!-- Setup Required Banner (shown when no credentials) -->
    <div id="setupBanner" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #141414; border: 1px solid #252525; padding: 40px; border-radius: 16px; text-align: center; z-index: 1000; box-shadow: 0 20px 60px rgba(0,0,0,0.5); max-width: 400px;">
        <div style="font-size: 3rem; margin-bottom: 16px;">&#9881;</div>
        <h2 style="color: #fff; margin-bottom: 12px;">Setup Required</h2>
        <p style="color: #888; margin-bottom: 24px; font-size: 0.9rem;">Configure your Webex Connect widget credentials to get started.</p>
        <button onclick="showSetupModal()" style="background: #00d4aa; color: #0d0d0d; border: none; padding: 14px 32px; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,212,170,0.3)'; this.style.background='#00b894';" onmouseout="this.style.transform='none'; this.style.boxShadow='none'; this.style.background='#00d4aa';">
            <span>&#9881;</span> Configure Widget
        </button>
    </div>

    <!-- Webex Connect Chatbot Widget -->
    <div id="divicw" data-bind="" data-org="" data-guid=""></div>

    <!-- Setup Modal -->
    <div class="setup-modal" id="setupModal">
        <div class="setup-content">
            <div class="setup-header">
                <h2>Configure WidgetScope</h2>
                <p>Enter your Webex Connect widget credentials</p>
            </div>

            <div class="setup-grid">
                <!-- Left Column - Credentials -->
                <div class="setup-column">
                    <div class="setup-column-title">Widget Credentials</div>

                    <div class="setup-field">
                        <label>Quick Setup - Paste Installation Snippet</label>
                        <textarea id="setupSnippet" rows="2" placeholder="Paste installation code from Webex Engage..."></textarea>
                        <small>Webex Engage &rarr; Assets &rarr; Channel Assets &rarr; LiveChat &rarr; Edit &rarr; Installation</small>
                    </div>

                    <div class="setup-field">
                        <label>Widget GUID</label>
                        <input type="text" id="setupGuid" placeholder="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
                        <small>The data-guid value</small>
                    </div>

                    <div class="setup-field">
                        <label>Bind ID</label>
                        <input type="text" id="setupBind" placeholder="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX">
                        <small>The data-bind value</small>
                    </div>

                    <div class="setup-field">
                        <label>Organization Name (optional)</label>
                        <input type="text" id="setupOrg" placeholder="e.g., Your Company Name">
                        <small>Displayed in sidebar</small>
                    </div>
                </div>

                <!-- Right Column - Instructions -->
                <div class="setup-column">
                    <div class="setup-column-title">Required Configuration</div>

                    <div style="background: #1c1414; border: 1px solid #ef4444; border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                        <p style="color: #ef4444; font-size: 0.7rem; font-weight: 600; margin-bottom: 8px;">&#9888; Whitelist This Domain</p>
                        <p style="color: #ccc; font-size: 0.65rem; margin-bottom: 8px; line-height: 1.4;"><strong>1. Webex Engage:</strong> Add <code style="background: #0d0d0d; padding: 2px 4px; border-radius: 3px; font-size: 0.6rem;">widgetscope.vercel.app</code> to your LiveChat asset's <strong>Websites</strong> tab.</p>
                        <p style="color: #ccc; font-size: 0.65rem; margin: 0; line-height: 1.4;"><strong>2. Webex Connect Flow:</strong> Add domain to Custom Variables:<br>
                        <span style="color: #888; font-size: 0.6rem;">Services &rarr; [Service] &rarr; Flows &rarr; [Flow] &rarr; Edit &rarr; Settings &rarr; Custom Variables &rarr; <code style="background: #0d0d0d; padding: 1px 3px; border-radius: 3px;">liveChatDomain</code></span></p>
                    </div>

                    <div style="background: #141c1a; border: 1px solid #00d4aa; border-radius: 8px; padding: 12px;">
                        <p style="color: #00d4aa; font-size: 0.7rem; font-weight: 600; margin-bottom: 6px;">Need Help?</p>
                        <p style="color: #ccc; font-size: 0.65rem; margin-bottom: 6px; line-height: 1.4;"><a href="https://webexcc.github.io/pages/Digital/" target="_blank" style="color: #00d4aa;">View official setup guide &rarr;</a></p>
                        <p style="color: #888; font-size: 0.6rem; font-style: italic; line-height: 1.4; margin: 0;">
                            Not an official Cisco/Webex product. Questions? <a href="mailto:chris@klopconsulting.com" style="color: #00d4aa;">chris@klopconsulting.com</a>
                        </p>
                    </div>
                </div>
            </div>

            <div class="setup-footer">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <a href="https://github.com/chrisklop/widgetscope" target="_blank" style="color: #666; font-size: 0.7rem; text-decoration: none;">
                        GitHub &rarr;
                    </a>
                </div>
                <div class="setup-actions">
                    <button class="setup-btn secondary" onclick="closeSetupModal()">Cancel</button>
                    <button class="setup-btn primary" onclick="saveConfig()">Save & Load</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // Widget Configuration Functions
        // ========================================

        // Get config from URL params or localStorage
        function getWidgetConfig() {
            const params = new URLSearchParams(window.location.search);
            const stored = JSON.parse(localStorage.getItem('widgetScopeConfig') || '{}');

            return {
                guid: params.get('guid') || stored.guid || '',
                bind: params.get('bind') || stored.bind || '',
                org: params.get('org') || stored.org || 'Your Organization'
            };
        }

        // Parse installation snippet to extract GUID and Bind ID
        function parseInstallationSnippet(snippet) {
            const result = { guid: '', bind: '' };

            // Look for data-guid="..."
            const guidMatch = snippet.match(/data-guid=["']([^"']+)["']/i);
            if (guidMatch) {
                result.guid = guidMatch[1];
            }

            // Look for data-bind="..."
            const bindMatch = snippet.match(/data-bind=["']([^"']+)["']/i);
            if (bindMatch) {
                result.bind = bindMatch[1];
            }

            return result;
        }

        // Show setup modal
        function showSetupModal() {
            const config = getWidgetConfig();
            document.getElementById('setupGuid').value = config.guid;
            document.getElementById('setupBind').value = config.bind;
            document.getElementById('setupOrg').value = config.org === 'Your Organization' ? '' : config.org;
            document.getElementById('setupSnippet').value = '';
            document.getElementById('setupModal').classList.add('show');

            // Add paste listener to snippet textarea
            const snippetField = document.getElementById('setupSnippet');
            snippetField.onpaste = function(e) {
                setTimeout(() => {
                    const parsed = parseInstallationSnippet(snippetField.value);
                    if (parsed.guid) {
                        document.getElementById('setupGuid').value = parsed.guid;
                    }
                    if (parsed.bind) {
                        document.getElementById('setupBind').value = parsed.bind;
                    }
                    if (parsed.guid && parsed.bind) {
                        snippetField.style.borderColor = '#28a745';
                        snippetField.placeholder = 'Credentials extracted successfully!';
                    }
                }, 50);
            };

            // Also handle manual typing/changes
            snippetField.oninput = function() {
                const parsed = parseInstallationSnippet(snippetField.value);
                if (parsed.guid) {
                    document.getElementById('setupGuid').value = parsed.guid;
                }
                if (parsed.bind) {
                    document.getElementById('setupBind').value = parsed.bind;
                }
                if (parsed.guid && parsed.bind) {
                    snippetField.style.borderColor = '#28a745';
                }
            };
        }

        // Close setup modal
        function closeSetupModal() {
            document.getElementById('setupModal').classList.remove('show');
        }

        // Save config to localStorage and reload
        function saveConfig() {
            // First check if there's a snippet to parse
            const snippet = document.getElementById('setupSnippet').value;
            if (snippet) {
                const parsed = parseInstallationSnippet(snippet);
                if (parsed.guid) document.getElementById('setupGuid').value = parsed.guid;
                if (parsed.bind) document.getElementById('setupBind').value = parsed.bind;
            }

            const config = {
                guid: document.getElementById('setupGuid').value.trim(),
                bind: document.getElementById('setupBind').value.trim(),
                org: document.getElementById('setupOrg').value.trim() || 'Your Organization'
            };

            if (!config.guid || !config.bind) {
                alert('Please enter both GUID and Bind ID, or paste your installation snippet');
                return;
            }

            localStorage.setItem('widgetScopeConfig', JSON.stringify(config));
            applyConfig(config);
            hideSetupBanner();
            closeSetupModal();
            showToast('Configuration saved! Reloading widget...');

            // Reload the widget
            setTimeout(() => {
                window.location.reload();
            }, 500);
        }

        // Apply config to the page
        function applyConfig(config) {
            const widgetDiv = document.getElementById('divicw');
            if (widgetDiv) {
                widgetDiv.setAttribute('data-guid', config.guid);
                widgetDiv.setAttribute('data-bind', config.bind);
            }

            const orgBadge = document.getElementById('orgBadge');
            if (orgBadge) {
                orgBadge.textContent = config.org;
            }
        }

        // Show/hide setup banner
        function showSetupBanner() {
            document.getElementById('setupBanner').style.display = 'block';
        }

        function hideSetupBanner() {
            document.getElementById('setupBanner').style.display = 'none';
        }

        // Initialize config on page load
        (function initConfig() {
            const config = getWidgetConfig();

            // If no config and no URL params, show setup banner and modal
            if (!config.guid || !config.bind) {
                // Show setup banner (persists if modal is closed)
                showSetupBanner();
                // Also show setup modal after a brief delay
                setTimeout(() => showSetupModal(), 500);
            } else {
                hideSetupBanner();
                applyConfig(config);
            }
        })();

        // ========================================
        // Session Tracking
        // ========================================

        // Session tracking
        const sessionStartTime = Date.now();
        const sessionUUID = 'dbg-' + Math.random().toString(36).substr(2, 9);
        document.getElementById('sessionId').textContent = sessionUUID;
        document.getElementById('sessionStart').textContent = new Date().toLocaleTimeString();

        setInterval(() => {
            const duration = Math.floor((Date.now() - sessionStartTime) / 1000);
            const mins = Math.floor(duration / 60);
            const secs = duration % 60;
            document.getElementById('sessionDuration').textContent = `${mins}m ${secs}s`;
        }, 1000);

        // Toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 2000);
        }

        // Noise patterns to filter
        const NOISE_PATTERNS = {
            devtools: [
                'react-devtools',
                'redux-devtools',
                '__REACT_DEVTOOLS',
                'chrome-extension://',
                'moz-extension://'
            ],
            debugPanel: [
                'debug_panel',
                'debug_test'
            ]
        };

        // Status Orb Controller
        const statusOrb = {
            currentState: 'initializing', // 'ok', 'warning', 'error', 'initializing'
            hasErrors: false,
            hasWarnings: false,
            warningCount: 0,
            errorCount: 0,

            setState: function(state) {
                this.currentState = state;
                const core = document.getElementById('statusOrbCore');
                const ring = document.getElementById('statusOrbRing1');
                const label = document.getElementById('statusOrbText');

                // Remove all state classes
                const stateClasses = ['warning', 'error'];
                [core, ring].forEach(el => {
                    if (el) stateClasses.forEach(cls => el.classList.remove(cls));
                });
                if (label) stateClasses.forEach(cls => label.classList.remove(cls));

                // Apply new state
                if (state === 'error') {
                    [core, ring].forEach(el => {
                        if (el) el.classList.add('error');
                    });
                    if (label) {
                        label.classList.add('error');
                        label.textContent = 'Error';
                    }
                } else if (state === 'warning') {
                    [core, ring].forEach(el => {
                        if (el) el.classList.add('warning');
                    });
                    if (label) {
                        label.classList.add('warning');
                        label.textContent = 'Warning';
                    }
                } else if (state === 'ok') {
                    if (label) label.textContent = 'Connected';
                } else {
                    if (label) label.textContent = 'Initializing';
                }
            },

            checkStatus: function() {
                // Determine current status based on all factors
                if (this.hasErrors || this.errorCount > 0) {
                    this.setState('error');
                } else if (this.hasWarnings || this.warningCount > 0) {
                    this.setState('warning');
                } else {
                    // Check if widget is properly loaded
                    const widgetState = document.getElementById('widgetState');
                    const scriptState = document.getElementById('scriptState');

                    if (widgetState && scriptState) {
                        const widgetReady = widgetState.classList.contains('online');
                        const scriptReady = scriptState.classList.contains('online');

                        if (widgetReady && scriptReady) {
                            this.setState('ok');
                        } else if (widgetState.textContent === 'Not Configured' ||
                                   widgetState.textContent === 'Domain Not Whitelisted') {
                            this.setState('error');
                        } else {
                            this.setState('initializing');
                        }
                    }
                }
            },

            logError: function() {
                this.errorCount++;
                this.hasErrors = true;
                this.checkStatus();
            },

            logWarning: function() {
                this.warningCount++;
                this.hasWarnings = true;
                this.checkStatus();
            },

            clearAlerts: function() {
                this.hasErrors = false;
                this.hasWarnings = false;
                this.warningCount = 0;
                this.errorCount = 0;
                this.checkStatus();
            },

            showDetails: function() {
                const status = this.currentState;
                const details = {
                    status: status,
                    errors: this.errorCount,
                    warnings: this.warningCount,
                    widget: document.getElementById('widgetState')?.textContent || 'unknown',
                    script: document.getElementById('scriptState')?.textContent || 'unknown'
                };
                console.log('Status Orb Details:', details);
                showToast(`Status: ${status.toUpperCase()} | Errors: ${this.errorCount} | Warnings: ${this.warningCount}`);
            }
        };

        // Debug Tools Object
        const debugTools = {
            logs: {
                console: [],
                postMessage: [],
                network: [],
                events: [],
                browserConsole: []
            },
            rawLogs: {
                postMessage: []
            },
            entryIndex: 0,
            widgetConfig: null,
            filters: {
                devtools: true,
                debugPanel: false,
                collapse: true
            },
            lastPostMessage: null,
            repeatCount: 0,
            filteredCount: 0,
            widgetMessageCount: 0,

            isNoise: function(data, origin) {
                const dataStr = typeof data === 'string' ? data : JSON.stringify(data || '');

                // Check devtools noise
                if (this.filters.devtools) {
                    for (const pattern of NOISE_PATTERNS.devtools) {
                        if (dataStr.includes(pattern) || (origin && origin.includes(pattern))) {
                            return 'devtools';
                        }
                    }
                }

                // Check debug panel noise
                if (this.filters.debugPanel) {
                    for (const pattern of NOISE_PATTERNS.debugPanel) {
                        if (dataStr.includes(pattern)) {
                            return 'debugPanel';
                        }
                    }
                }

                return false;
            },

            categorizeMessage: function(data, origin) {
                // Widget messages from IMI
                if (origin && origin.includes('imi.chat')) {
                    return 'widget';
                }
                if (origin && origin.includes('media.imi')) {
                    return 'widget';
                }

                // Browser extension noise
                const dataStr = typeof data === 'string' ? data : JSON.stringify(data || '');
                for (const pattern of NOISE_PATTERNS.devtools) {
                    if (dataStr.includes(pattern)) {
                        return 'browser';
                    }
                }

                // Debug panel messages
                if (dataStr.includes('debug_panel') || dataStr.includes('debug_test')) {
                    return 'debug';
                }

                return 'other';
            },

            isDuplicate: function(type, message, data) {
                if (!this.filters.collapse) return false;
                if (type !== 'postMessage') return false;

                const current = JSON.stringify({ message, data });
                if (current === this.lastPostMessage) {
                    this.repeatCount++;
                    return true;
                }

                this.lastPostMessage = current;
                this.repeatCount = 0;
                return false;
            },

            toggleFilter: function(filterName) {
                this.filters[filterName] = document.getElementById(
                    filterName === 'devtools' ? 'filterDevtools' :
                    filterName === 'debugPanel' ? 'filterDebugPanel' : 'collapseRepeats'
                ).checked;
                this.rerenderPostMessages();
            },

            rerenderPostMessages: function() {
                const container = document.getElementById('postMessageLogs');
                container.innerHTML = '';
                this.logs.postMessage = [];
                this.filteredCount = 0;
                this.widgetMessageCount = 0;
                this.lastPostMessage = null;
                this.repeatCount = 0;

                for (const raw of this.rawLogs.postMessage) {
                    this.processPostMessage(raw.origin, raw.data, raw.timestamp, false);
                }

                this.updateFilterStats();
            },

            processPostMessage: function(origin, data, timestamp, isNew = true) {
                if (isNew) {
                    this.rawLogs.postMessage.push({ origin, data, timestamp });
                }

                const noiseType = this.isNoise(data, origin);
                if (noiseType) {
                    this.filteredCount++;
                    this.updateFilterStats();
                    return;
                }

                const category = this.categorizeMessage(data, origin);
                if (category === 'widget') {
                    this.widgetMessageCount++;
                    document.getElementById('messageCount').textContent = this.widgetMessageCount;
                }

                // Check for widget config in loadstyles action
                if (data && data.action === 'loadstyles' && data.message) {
                    try {
                        const config = JSON.parse(data.message);
                        this.parseWidgetConfig(config);
                    } catch (e) {}
                }

                // Check for fingerprint
                if (data && data.action === 'setlocal' && data.key === 'fingerprint') {
                    document.getElementById('fingerprint').textContent = data.value.substring(0, 12) + '...';
                }

                const message = `Origin: ${origin}`;

                // Check for duplicate
                if (this.isDuplicate('postMessage', message, data)) {
                    // Update last entry with count
                    const container = document.getElementById('postMessageLogs');
                    const lastEntry = container.lastElementChild;
                    if (lastEntry) {
                        let countBadge = lastEntry.querySelector('.collapse-count');
                        if (!countBadge) {
                            countBadge = document.createElement('span');
                            countBadge.className = 'collapse-count';
                            lastEntry.querySelector('.log-message').appendChild(countBadge);
                        }
                        countBadge.textContent = `x${this.repeatCount + 1}`;
                    }
                    return;
                }

                const entry = {
                    timestamp: timestamp || new Date().toISOString(),
                    message,
                    data,
                    logType: category === 'widget' ? 'widget-message' :
                             category === 'browser' ? 'browser-noise' : 'postmessage',
                    category,
                    id: this.entryIndex++
                };

                this.logs.postMessage.push(entry);
                this.renderPostMessageLog(entry);
                this.updateCounts();
            },

            highlightBooleans: function(jsonStr) {
                // Replace true/false with colored spans
                return jsonStr
                    .replace(/"([^"]+)":\s*true/g, '"$1": <span class="bool-true">true</span>')
                    .replace(/"([^"]+)":\s*false/g, '"$1": <span class="bool-false">false</span>')
                    .replace(/:\s*true([,\n\r\s}])/g, ': <span class="bool-true">true</span>$1')
                    .replace(/:\s*false([,\n\r\s}])/g, ': <span class="bool-false">false</span>$1');
            },

            renderPostMessageLog: function(entry) {
                const container = document.getElementById('postMessageLogs');
                if (!container) return;

                const div = document.createElement('div');
                div.className = `log-entry ${entry.logType}`;
                div.setAttribute('data-entry-id', entry.id);

                const sourceTag = entry.category === 'widget' ? '<span class="source-tag widget">WIDGET</span>' :
                                  entry.category === 'browser' ? '<span class="source-tag browser">BROWSER</span>' :
                                  entry.category === 'debug' ? '<span class="source-tag debug">DEBUG</span>' : '';

                let html = `<button class="entry-copy-btn" onclick="debugTools.copyEntry(${entry.id}, 'postMessage', this)">Copy</button>`;
                html += `<div class="log-time">${entry.timestamp}</div>`;
                html += `<div class="log-message">${sourceTag}${this.escapeHtml(entry.message)}</div>`;

                if (entry.data) {
                    try {
                        // For widget config, show abbreviated version
                        let displayData = entry.data;
                        if (entry.data.action === 'loadstyles' && entry.data.message) {
                            displayData = { action: 'loadstyles', message: '[Widget Config - see sidebar]' };
                        }
                        const jsonStr = typeof displayData === 'string' ? displayData : JSON.stringify(displayData, null, 2);
                        // Highlight boolean values with colors
                        const highlightedJson = this.highlightBooleans(this.escapeHtml(jsonStr));
                        html += `<div class="log-json">${highlightedJson}</div>`;
                    } catch (e) {
                        html += `<div class="log-json">[Unable to stringify]</div>`;
                    }
                }

                div.innerHTML = html;
                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
            },

            parseWidgetConfig: function(config) {
                this.widgetConfig = config;
                const container = document.getElementById('widgetConfigContent');

                const items = [
                    { label: 'App ID', value: config.appid },
                    { label: 'Name', value: config.name },
                    { label: 'Website ID', value: config.website_id },
                    { label: 'Agent Avail', value: config.agent_avail === 1 ? 'Yes' : 'No', class: config.agent_avail === 1 ? 'success' : 'warning' },
                    { label: 'Proactive', value: config.enable_proactive ? 'Yes' : 'No' },
                    { label: 'Attachments', value: config.isattachmentenabled ? 'Yes' : 'No' },
                    { label: 'Emoji', value: config.isemojienable ? 'Yes' : 'No' },
                    { label: 'Language', value: config.widget_lang },
                    { label: 'Color', value: config.widgetcolor }
                ];

                container.innerHTML = items.map(item => `
                    <div class="config-item">
                        <span class="config-label">${item.label}</span>
                        <span class="config-value ${item.class || ''}">${item.value || '-'}</span>
                    </div>
                `).join('');

                this.addLog('events', 'Widget config received', { appid: config.appid, name: config.name }, 'success');
            },

            copyWidgetConfig: function() {
                if (this.widgetConfig) {
                    navigator.clipboard.writeText(JSON.stringify(this.widgetConfig, null, 2)).then(() => {
                        showToast('Widget config copied!');
                    });
                } else {
                    showToast('No widget config received yet');
                }
            },

            updateFilterStats: function() {
                const shown = this.logs.postMessage.length;
                const filtered = this.filteredCount;
                document.getElementById('filterStats').textContent = `Filtered: ${filtered} | Shown: ${shown}`;

                const filteredBadge = document.getElementById('postMessageFiltered');
                if (filtered > 0) {
                    filteredBadge.style.display = 'inline';
                    filteredBadge.textContent = `${filtered} hidden`;
                } else {
                    filteredBadge.style.display = 'none';
                }
            },

            addLog: function(type, message, data = null, logType = 'info') {
                const timestamp = new Date().toISOString();
                const entry = { timestamp, message, data, logType, id: this.entryIndex++ };
                this.logs[type].push(entry);
                this.renderLog(type, entry);
                this.updateCounts();
            },

            addBrowserConsoleLog: function(message, logType = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const entry = { timestamp, message, logType, id: this.entryIndex++ };
                this.logs.browserConsole.push(entry);

                const container = document.getElementById('browserConsoleLogs');
                if (!container) return;

                const div = document.createElement('div');
                div.className = `log-entry ${logType}`;
                div.setAttribute('data-entry-id', entry.id);

                const prefix = logType === 'error' ? '[ERR]' :
                               logType === 'warn' ? '[WARN]' :
                               logType === 'info' ? '[LOG]' : '[LOG]';

                div.innerHTML = `
                    <button class="entry-copy-btn" onclick="debugTools.copyEntry(${entry.id}, 'browserConsole', this)">Copy</button>
                    <span class="log-time" style="color: #888; font-size: 0.65rem;">${timestamp}</span>
                    <span style="color: ${logType === 'error' ? '#ff6b6b' : logType === 'warn' ? '#ffc107' : '#888'}; font-size: 0.65rem; margin: 0 4px;">${prefix}</span>
                    <span class="log-message" style="font-size: 0.7rem;">${this.escapeHtml(message)}</span>
                `;

                container.appendChild(div);
                container.scrollTop = container.scrollHeight;

                // Update count
                document.getElementById('browserConsoleCount').textContent = this.logs.browserConsole.length;
            },

            renderLog: function(type, entry) {
                const containerId = type === 'console' ? 'consoleLogs' :
                                   type === 'network' ? 'networkLogs' : 'eventLogs';
                const container = document.getElementById(containerId);
                if (!container) return;

                const div = document.createElement('div');
                div.className = `log-entry ${entry.logType}`;
                div.setAttribute('data-entry-id', entry.id);

                let html = `<button class="entry-copy-btn" onclick="debugTools.copyEntry(${entry.id}, '${type}', this)">Copy</button>`;
                html += `<div class="log-time">${entry.timestamp}</div>`;
                html += `<div class="log-message">${this.escapeHtml(entry.message)}</div>`;

                if (entry.data) {
                    try {
                        const jsonStr = typeof entry.data === 'string' ? entry.data : JSON.stringify(entry.data, null, 2);
                        html += `<div class="log-json">${this.escapeHtml(jsonStr)}</div>`;
                    } catch (e) {
                        html += `<div class="log-json">[Unable to stringify]</div>`;
                    }
                }

                div.innerHTML = html;
                container.appendChild(div);
                container.scrollTop = container.scrollHeight;
            },

            escapeHtml: function(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            updateCounts: function() {
                document.getElementById('consoleCount').textContent = this.logs.console.length;
                document.getElementById('postMessageCount').textContent = this.logs.postMessage.length;
                document.getElementById('networkLogCount').textContent = this.logs.network.length;
                document.getElementById('networkCount').textContent = this.logs.network.length;
                document.getElementById('eventCount').textContent = this.logs.events.length;
            },

            copyEntry: function(entryId, type, btn) {
                const entry = this.logs[type].find(e => e.id === entryId);
                if (entry) {
                    const text = JSON.stringify(entry, null, 2);
                    navigator.clipboard.writeText(text).then(() => {
                        btn.textContent = 'OK!';
                        btn.classList.add('copied');
                        setTimeout(() => {
                            btn.textContent = 'Copy';
                            btn.classList.remove('copied');
                        }, 1000);
                    });
                }
            },

            copyPanelLogs: function(type) {
                const logs = type === 'postMessage' ?
                    this.logs.postMessage.filter(l => l.category === 'widget' || !this.filters.devtools) :
                    this.logs[type];
                const text = JSON.stringify(logs, null, 2);
                navigator.clipboard.writeText(text).then(() => {
                    showToast(`Copied ${logs.length} entries!`);
                });
            },

            copyFullReport: function() {
                const report = {
                    reportTime: new Date().toISOString(),
                    sessionId: sessionUUID,
                    sessionDuration: Math.floor((Date.now() - sessionStartTime) / 1000) + 's',
                    environment: {
                        url: window.location.href,
                        userAgent: navigator.userAgent,
                        screen: `${window.innerWidth}x${window.innerHeight}`,
                        widgetGuid: getWidgetConfig().guid || 'not configured'
                    },
                    widgetConfig: this.widgetConfig,
                    logs: {
                        console: this.logs.console,
                        browserConsole: this.logs.browserConsole,
                        postMessage: this.logs.postMessage.filter(l => l.category === 'widget'),
                        network: this.logs.network,
                        events: this.logs.events
                    },
                    stats: {
                        totalPostMessages: this.rawLogs.postMessage.length,
                        filteredOut: this.filteredCount,
                        widgetMessages: this.widgetMessageCount
                    },
                    safariDebug: typeof safariDebug !== 'undefined' ? safariDebug.getExportData() : null
                };
                navigator.clipboard.writeText(JSON.stringify(report, null, 2)).then(() => {
                    showToast('Full report copied (noise filtered)!');
                });
            },

            clearAllLogs: function() {
                this.logs = { console: [], postMessage: [], network: [], events: [] };
                this.rawLogs = { postMessage: [] };
                this.filteredCount = 0;
                this.widgetMessageCount = 0;
                this.lastPostMessage = null;
                this.repeatCount = 0;
                ['consoleLogs', 'postMessageLogs', 'networkLogs', 'eventLogs'].forEach(id => {
                    document.getElementById(id).innerHTML = '';
                });
                this.updateCounts();
                this.updateFilterStats();
                document.getElementById('messageCount').textContent = '0';
                this.addLog('events', 'Logs cleared', null, 'info');
                // Clear status orb alerts
                statusOrb.clearAlerts();
                // Clear Safari debug mini-logs
                if (typeof safariDebug !== 'undefined') {
                    safariDebug.clearLogs();
                }
            },

            exportLogs: function() {
                const exportData = {
                    exportTime: new Date().toISOString(),
                    sessionId: sessionUUID,
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                    widgetConfig: this.widgetConfig,
                    logs: {
                        console: this.logs.console,
                        browserConsole: this.logs.browserConsole,
                        postMessage: this.logs.postMessage.filter(l => l.category === 'widget'),
                        network: this.logs.network,
                        events: this.logs.events
                    },
                    safariDebug: typeof safariDebug !== 'undefined' ? safariDebug.getExportData() : null
                };
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `webex-debug-${sessionUUID}.json`;
                a.click();
                URL.revokeObjectURL(url);
                this.addLog('events', 'Logs exported', null, 'success');
            },

            reloadWidget: function() {
                this.addLog('events', 'Reloading widget...', null, 'info');

                // Remove existing IMI script
                const existingScript = document.querySelector('script[src*="imichatinit.js"]');
                if (existingScript) existingScript.remove();

                // Remove all widget-related elements (iframes, icw elements)
                const widgetElements = document.querySelectorAll('[id*="icw"], [class*="icw"], iframe[src*="imi"], #imi-chatbutton, #imichat-fullscreen-modal');
                widgetElements.forEach(el => el.remove());

                // Recreate the divicw container if it was removed
                if (!document.getElementById('divicw')) {
                    const config = getWidgetConfig();
                    const newDiv = document.createElement('div');
                    newDiv.id = 'divicw';
                    newDiv.setAttribute('data-bind', config.bind || '');
                    newDiv.setAttribute('data-org', '');
                    newDiv.setAttribute('data-guid', config.guid || '');
                    document.body.appendChild(newDiv);
                    this.addLog('events', 'Recreated widget container', null, 'info');
                }

                this.widgetConfig = null;
                document.getElementById('widgetConfigContent').innerHTML = '<div class="config-item"><span class="config-label">Status</span><span class="config-value warning">Reloading...</span></div>';

                setTimeout(() => initWidget(), 500);
            },

            inspectWidget: function() {
                const widgetInfo = {
                    divicw: !!document.getElementById('divicw'),
                    iframes: document.querySelectorAll('iframe').length,
                    icwElements: document.querySelectorAll('[id*="icw"], [class*="icw"]').length,
                    IMIchat: typeof window.IMIchat,
                    icw: typeof window.icw,
                    configReceived: !!this.widgetConfig
                };
                this.addLog('events', 'Widget inspection', widgetInfo, 'info');
                showToast('Inspection logged');
            },

            checkConnectivity: function() {
                this.addLog('network', 'Pinging IMI servers...', null, 'info');
                const start = Date.now();
                fetch('https://media.imi.chat/widget/js/imichatinit.js', { method: 'HEAD', mode: 'no-cors' })
                    .then(() => {
                        const latency = Date.now() - start;
                        this.addLog('network', `IMI server OK (${latency}ms)`, { latency }, 'success');
                    })
                    .catch(err => {
                        this.addLog('network', 'IMI server unreachable', { error: err.message }, 'error');
                    });
            },

            updateWidgetState: function(state, isOnline) {
                const el = document.getElementById('widgetState');
                el.textContent = state;
                el.className = 'state-value ' + (isOnline ? 'online' : (state === 'Loading' ? 'pending' : 'offline'));
            },

            updateScriptState: function(state, isLoaded) {
                const el = document.getElementById('scriptState');
                el.textContent = state;
                el.className = 'state-value ' + (isLoaded ? 'online' : 'pending');
            },

            updateStatus: function(text, color) {
                document.getElementById('statusText').textContent = text;
                document.getElementById('statusDot').style.background = color;
                // Update status orb based on status
                setTimeout(() => statusOrb.checkStatus(), 100);
            }
        };

        // Override console methods with recursion guard
        const originalConsole = {
            log: console.log.bind(console),
            error: console.error.bind(console),
            warn: console.warn.bind(console),
            info: console.info.bind(console)
        };

        let isLoggingToPanel = false;

        function safeLogToPanel(type, args, logType) {
            if (isLoggingToPanel) return;
            if (args.length === 0) return;

            const message = args.map(a => {
                if (a === undefined) return 'undefined';
                if (a === null) return 'null';
                if (typeof a === 'object') {
                    try { return JSON.stringify(a); } catch { return String(a); }
                }
                return String(a);
            }).join(' ').trim();

            if (!message || message === '' || message === 'undefined' || message === 'null') return;

            isLoggingToPanel = true;
            try {
                debugTools.addLog(type, message, null, logType);
                // Also log to Browser Console panel
                debugTools.addBrowserConsoleLog(message, logType);
            } finally {
                isLoggingToPanel = false;
            }
        }

        console.log = function(...args) {
            originalConsole.log(...args);
            safeLogToPanel('console', args, 'info');
        };

        console.error = function(...args) {
            originalConsole.error(...args);
            safeLogToPanel('console', args, 'error');
            // Update status orb for errors
            statusOrb.logError();
        };

        console.warn = function(...args) {
            originalConsole.warn(...args);
            safeLogToPanel('console', args, 'warn');
            // Update status orb for warnings
            statusOrb.logWarning();
        };

        console.info = function(...args) {
            originalConsole.info(...args);
            safeLogToPanel('console', args, 'info');
        };

        // Intercept postMessage with filtering
        window.addEventListener('message', function(event) {
            let data = event.data;
            let displayData = data;

            try {
                if (typeof data === 'string' && (data.startsWith('{') || data.startsWith('['))) {
                    displayData = JSON.parse(data);
                }
            } catch (e) {}

            debugTools.processPostMessage(event.origin, displayData, new Date().toISOString(), true);
        }, false);

        // Intercept XHR requests
        const originalXHR = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
            const xhr = new originalXHR();
            const originalOpen = xhr.open.bind(xhr);
            const originalSend = xhr.send.bind(xhr);

            xhr.open = function(method, url, ...rest) {
                xhr._debugUrl = url;
                xhr._debugMethod = method;
                return originalOpen(method, url, ...rest);
            };

            xhr.send = function(body) {
                const startTime = Date.now();

                xhr.addEventListener('load', function() {
                    const duration = Date.now() - startTime;
                    let responseData = null;
                    try {
                        responseData = JSON.parse(xhr.responseText);
                    } catch (e) {
                        responseData = xhr.responseText?.substring(0, 300);
                    }

                    debugTools.addLog('network',
                        `${xhr._debugMethod} ${xhr._debugUrl} - ${xhr.status} (${duration}ms)`,
                        { status: xhr.status, response: responseData },
                        xhr.status >= 400 ? 'error' : 'network'
                    );
                });

                xhr.addEventListener('error', function() {
                    debugTools.addLog('network',
                        `${xhr._debugMethod} ${xhr._debugUrl} - FAILED`,
                        { error: 'Network Error' },
                        'error'
                    );
                });

                return originalSend(body);
            };

            return xhr;
        };

        // Intercept Fetch requests
        const originalFetch = window.fetch;
        window.fetch = function(url, options = {}) {
            const startTime = Date.now();
            const method = options.method || 'GET';

            return originalFetch(url, options).then(response => {
                const duration = Date.now() - startTime;
                const clonedResponse = response.clone();

                clonedResponse.text().then(text => {
                    let responseData = null;
                    try {
                        responseData = JSON.parse(text);
                    } catch (e) {
                        responseData = text?.substring(0, 300);
                    }

                    debugTools.addLog('network',
                        `${method} ${url} - ${response.status} (${duration}ms)`,
                        { status: response.status, response: responseData },
                        response.status >= 400 ? 'error' : 'network'
                    );
                }).catch(() => {});

                // Log non-OK responses to Browser Console
                if (!response.ok) {
                    debugTools.addBrowserConsoleLog(`Fetch ${response.status}: ${url}`, 'error');
                }
                return response;
            }).catch(error => {
                debugTools.addLog('network',
                    `${method} ${url} - FAILED`,
                    { error: error.message },
                    'error'
                );
                debugTools.addBrowserConsoleLog(`Fetch error: ${error.message}`, 'error');
                throw error;
            });
        };

        // Watch for DOM changes
        const observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.nodeType === 1) {
                        if (node.tagName === 'IFRAME' || node.id?.includes('icw') || node.className?.includes('icw')) {
                            debugTools.addLog('events', `Widget element: ${node.tagName} ${node.id || node.className}`, null, 'success');
                        }
                    }
                });
            });
        });

        observer.observe(document.body, { childList: true, subtree: true });

        // Widget initialization
        function initWidget() {
            // Check if credentials are configured
            const config = getWidgetConfig();
            if (!config.guid || !config.bind) {
                debugTools.addLog('events', 'Widget not configured - waiting for credentials', null, 'warning');
                debugTools.updateStatus('Not Configured', '#ffc107');
                debugTools.updateWidgetState('Not Configured', false);
                debugTools.updateScriptState('Waiting', false);
                return;
            }

            debugTools.addLog('events', 'Starting widget init...', null, 'info');
            debugTools.updateStatus('Loading...', '#ffc107');

            try {
                var e = document.getElementById("divicw");
                if (!e) {
                    debugTools.addLog('console', 'Widget container not found', null, 'error');
                    return;
                }

                var t = document.createElement("script");
                t.src = "https://media.imi.chat/widget/js/imichatinit.js?t=" + new Date().toISOString();

                debugTools.addLog('network', `Loading: ${t.src.substring(0, 60)}...`, null, 'network');

                e.insertAdjacentElement("afterend", t);

                t.addEventListener("load", function() {
                    debugTools.addLog('events', 'Script loaded!', null, 'success');
                    debugTools.updateStatus('Widget Ready', '#28a745');
                    debugTools.updateWidgetState('Ready', true);
                    debugTools.updateScriptState('Loaded', true);
                });

                t.addEventListener("error", function(err) {
                    debugTools.addLog('events', 'Script load failed', null, 'error');
                    debugTools.updateStatus('Failed', '#dc3545');
                    debugTools.updateWidgetState('Failed', false);
                    debugTools.updateScriptState('Error', false);
                });
            } catch (err) {
                debugTools.addLog('console', `Init error: ${err.message}`, null, 'error');
            }
        }

        // Global error handler - captures JS errors
        window.addEventListener('error', function(event) {
            // Check if it's a resource load error (e.g., 404)
            if (event.target && (event.target.tagName === 'SCRIPT' || event.target.tagName === 'LINK' || event.target.tagName === 'IMG')) {
                const url = event.target.src || event.target.href || 'unknown';
                debugTools.addBrowserConsoleLog(`Failed to load resource: ${url}`, 'error');
                debugTools.addLog('network', `Failed to load: ${url.substring(0, 60)}...`, null, 'error');
            } else if (event.message) {
                debugTools.addLog('console', `Error: ${event.message}`, {
                    file: event.filename?.split('/').pop(),
                    line: event.lineno
                }, 'error');
                debugTools.addBrowserConsoleLog(`${event.message} (${event.filename?.split('/').pop()}:${event.lineno})`, 'error');
            }
        }, true); // Use capture phase to catch resource errors

        window.addEventListener('unhandledrejection', function(event) {
            debugTools.addLog('console', `Promise rejected: ${event.reason}`, null, 'error');
            debugTools.addBrowserConsoleLog(`Unhandled Promise rejection: ${event.reason}`, 'error');
        });

        // Monitor dynamically added scripts for load errors (catches JSONP 404s)
        const scriptObserver = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                mutation.addedNodes.forEach(function(node) {
                    if (node.tagName === 'SCRIPT' && node.src) {
                        node.addEventListener('error', function() {
                            const url = node.src;
                            if (url.includes('chat-widget.imi.chat') || url.includes('imi.chat')) {
                                debugTools.addBrowserConsoleLog(`IMI request failed (404): ${url.substring(0, 80)}...`, 'error');
                                debugTools.addLog('network', `IMI 404: Domain not whitelisted?`, { url: url.substring(0, 100) }, 'error');
                                debugTools.updateStatus('Domain Not Whitelisted', '#dc3545');
                            } else {
                                debugTools.addBrowserConsoleLog(`Script load failed: ${url}`, 'error');
                            }
                        });
                    }
                });
            });
        });
        scriptObserver.observe(document.body, { childList: true, subtree: true });

        // ========================================
        // Safari WebSocket Debug Tools
        // ========================================

        const safariDebug = {
            // WebSocket tracking
            websockets: new Map(),
            wsIdCounter: 0,
            wsTotalOpened: 0,
            wsTotalMessages: { sent: 0, received: 0 },
            zombieCheckInterval: null,

            // MQTT tracking
            mqttConnections: new Map(),
            mqttStats: {
                connections: 0,
                published: 0,
                received: 0,
                subscribes: 0,
                pings: 0,
                topics: new Set()
            },
            mqttState: 'disconnected', // disconnected, connecting, connected

            // Visibility tracking
            visibilityState: document.visibilityState,
            visibilityTransitions: 0,
            timeVisible: 0,
            timeHidden: 0,
            lastVisibilityChange: Date.now(),

            // Network tracking
            networkTransitions: 0,

            // Browser info
            browserInfo: null,

            // Storage test results
            storageResults: null,

            // Section collapse state
            collapsedSections: new Set(['visibility', 'browser', 'networkStatus', 'storage']),

            // Initialize all Safari debug features
            init: function() {
                this.interceptWebSocket();
                this.initVisibilityTracking();
                this.initNetworkTracking();
                this.detectBrowser();
                this.runStorageTest();
                this.startZombieDetection();
                this.loadSectionStates();

                debugTools.addLog('events', 'Safari debug tools initialized', null, 'success');
            },

            // Toggle section collapse
            toggleSection: function(sectionId) {
                const panel = document.getElementById(sectionId + 'Panel');
                if (!panel) return;

                if (this.collapsedSections.has(sectionId)) {
                    this.collapsedSections.delete(sectionId);
                    panel.classList.remove('collapsed');
                } else {
                    this.collapsedSections.add(sectionId);
                    panel.classList.add('collapsed');
                }

                this.saveSectionStates();
            },

            saveSectionStates: function() {
                try {
                    localStorage.setItem('widgetScope_collapsedSections',
                        JSON.stringify([...this.collapsedSections]));
                } catch (e) {}
            },

            loadSectionStates: function() {
                try {
                    const saved = localStorage.getItem('widgetScope_collapsedSections');
                    if (saved) {
                        this.collapsedSections = new Set(JSON.parse(saved));
                    }
                    // Apply initial state
                    this.collapsedSections.forEach(sectionId => {
                        const panel = document.getElementById(sectionId + 'Panel');
                        if (panel) panel.classList.add('collapsed');
                    });
                } catch (e) {}
            },

            // ========================================
            // WebSocket Interception
            // ========================================

            interceptWebSocket: function() {
                const self = this;
                const OriginalWebSocket = window.WebSocket;

                window.WebSocket = function(url, protocols) {
                    const wsId = ++self.wsIdCounter;
                    const ws = protocols ? new OriginalWebSocket(url, protocols) : new OriginalWebSocket(url);

                    const wsData = {
                        id: wsId,
                        ws: ws,
                        url: url,
                        protocols: protocols,
                        openTime: null,
                        closeTime: null,
                        state: 'connecting',
                        msgSent: 0,
                        msgReceived: 0,
                        lastActivity: Date.now(),
                        closeCode: null,
                        closeReason: null,
                        markedZombie: false
                    };

                    self.websockets.set(wsId, wsData);
                    self.logWsEvent(wsId, 'connecting', { url: url.substring(0, 60) + (url.length > 60 ? '...' : '') });

                    // Intercept onopen
                    ws.addEventListener('open', function(event) {
                        wsData.openTime = Date.now();
                        wsData.state = 'open';
                        wsData.lastActivity = Date.now();
                        self.wsTotalOpened++;
                        self.logWsEvent(wsId, 'open', { url: url.substring(0, 40) });
                        self.updateWsUI();

                        // Check if this is an MQTT connection and track it
                        if (self.isMqttUrl(url)) {
                            wsData.isMqtt = true;
                            if (!self.mqttConnections.has(wsId)) {
                                self.mqttConnections.set(wsId, {
                                    wsId: wsId,
                                    state: 'connecting',
                                    clientId: null,
                                    broker: url,
                                    topics: new Set()
                                });
                            } else {
                                self.mqttConnections.get(wsId).broker = url;
                            }
                            // Update broker URL in UI
                            document.getElementById('mqttBrokerUrl').textContent =
                                url.length > 40 ? url.substring(0, 40) + '...' : url;
                            debugTools.addLog('events', 'MQTT WebSocket opened', { url: url.substring(0, 50) }, 'info');
                        }
                    });

                    // Intercept onclose
                    ws.addEventListener('close', function(event) {
                        wsData.closeTime = Date.now();
                        wsData.state = 'closed';
                        wsData.closeCode = event.code;
                        wsData.closeReason = event.reason || 'No reason';

                        const duration = wsData.openTime ?
                            Math.round((wsData.closeTime - wsData.openTime) / 1000) : 0;

                        self.logWsEvent(wsId, 'close', {
                            code: event.code,
                            reason: wsData.closeReason.substring(0, 30),
                            duration: duration + 's',
                            wasClean: event.wasClean
                        });
                        self.updateWsUI();

                        // Handle MQTT connection close
                        if (wsData.isMqtt) {
                            self.onMqttWsClose(wsId);
                        }

                        // Correlate with visibility state
                        if (document.visibilityState === 'hidden') {
                            self.logWsEvent(wsId, 'correlation', { note: 'Closed while hidden' });
                        }
                    });

                    // Intercept onerror
                    ws.addEventListener('error', function(event) {
                        wsData.state = 'error';
                        self.logWsEvent(wsId, 'error', {
                            readyState: ws.readyState
                        });
                        self.updateWsUI();
                        statusOrb.logError();
                    });

                    // Intercept onmessage
                    ws.addEventListener('message', function(event) {
                        wsData.msgReceived++;
                        wsData.lastActivity = Date.now();
                        wsData.markedZombie = false; // Clear zombie flag on activity
                        self.wsTotalMessages.received++;

                        // Try to process as MQTT first
                        let isMqtt = false;
                        if (wsData.isMqtt || self.isMqttUrl(url)) {
                            wsData.isMqtt = true;
                            // Handle different data types for MQTT parsing
                            if (event.data instanceof Blob) {
                                event.data.arrayBuffer().then(function(buffer) {
                                    self.processMqttMessage(wsId, buffer, 'received');
                                });
                                isMqtt = true;
                            } else if (event.data instanceof ArrayBuffer) {
                                isMqtt = self.processMqttMessage(wsId, event.data, 'received');
                            } else if (typeof event.data === 'string') {
                                isMqtt = self.processMqttMessage(wsId, event.data, 'received');
                            }
                        }

                        let msgPreview = '';
                        try {
                            if (typeof event.data === 'string') {
                                msgPreview = event.data.substring(0, 150);
                                if (event.data.length > 150) msgPreview += '...';
                            } else if (event.data instanceof Blob) {
                                msgPreview = '[Blob: ' + event.data.size + ' bytes]' + (isMqtt ? ' (MQTT)' : '');
                            } else if (event.data instanceof ArrayBuffer) {
                                msgPreview = '[ArrayBuffer: ' + event.data.byteLength + ' bytes]' + (isMqtt ? ' (MQTT)' : '');
                            }
                        } catch (e) {
                            msgPreview = '[Unable to read]';
                        }

                        self.logWsEvent(wsId, 'recv', { preview: msgPreview });
                        self.updateWsUI();
                    });

                    // Intercept send
                    const originalSend = ws.send.bind(ws);
                    ws.send = function(data) {
                        wsData.msgSent++;
                        wsData.lastActivity = Date.now();
                        wsData.markedZombie = false;
                        self.wsTotalMessages.sent++;

                        // Try to process as MQTT first
                        let isMqtt = false;
                        if (wsData.isMqtt || self.isMqttUrl(url)) {
                            wsData.isMqtt = true;
                            if (data instanceof ArrayBuffer) {
                                isMqtt = self.processMqttMessage(wsId, data, 'sent');
                            } else if (typeof data === 'string') {
                                isMqtt = self.processMqttMessage(wsId, data, 'sent');
                            } else if (data instanceof Blob) {
                                // For Blob, we process async but mark as MQTT
                                data.arrayBuffer().then(function(buffer) {
                                    self.processMqttMessage(wsId, buffer, 'sent');
                                });
                                isMqtt = true;
                            }
                        }

                        let msgPreview = '';
                        try {
                            if (typeof data === 'string') {
                                msgPreview = data.substring(0, 150);
                                if (data.length > 150) msgPreview += '...';
                            } else if (data instanceof Blob) {
                                msgPreview = '[Blob: ' + data.size + ' bytes]' + (isMqtt ? ' (MQTT)' : '');
                            } else if (data instanceof ArrayBuffer) {
                                msgPreview = '[ArrayBuffer: ' + data.byteLength + ' bytes]' + (isMqtt ? ' (MQTT)' : '');
                            }
                        } catch (e) {
                            msgPreview = '[Unable to read]';
                        }

                        self.logWsEvent(wsId, 'sent', { preview: msgPreview });
                        self.updateWsUI();

                        return originalSend(data);
                    };

                    return ws;
                };

                // Copy static properties
                window.WebSocket.CONNECTING = OriginalWebSocket.CONNECTING;
                window.WebSocket.OPEN = OriginalWebSocket.OPEN;
                window.WebSocket.CLOSING = OriginalWebSocket.CLOSING;
                window.WebSocket.CLOSED = OriginalWebSocket.CLOSED;
                window.WebSocket.prototype = OriginalWebSocket.prototype;
            },

            // Zombie detection
            startZombieDetection: function() {
                const self = this;
                const ZOMBIE_THRESHOLD = 60000; // 60 seconds

                this.zombieCheckInterval = setInterval(function() {
                    const now = Date.now();

                    self.websockets.forEach((wsData, wsId) => {
                        if (wsData.state === 'open') {
                            const ws = wsData.ws;
                            const timeSinceActivity = now - wsData.lastActivity;

                            if (ws.readyState === WebSocket.OPEN && timeSinceActivity > ZOMBIE_THRESHOLD) {
                                if (!wsData.markedZombie) {
                                    wsData.markedZombie = true;
                                    self.logWsEvent(wsId, 'zombie', {
                                        lastActivity: Math.round(timeSinceActivity / 1000) + 's ago',
                                        note: 'Possible zombie'
                                    });
                                    self.updateWsUI();
                                    statusOrb.logWarning();
                                }
                            }
                        }
                    });
                }, 10000);
            },

            logWsEvent: function(wsId, type, data) {
                const timestamp = new Date().toLocaleTimeString();
                const container = document.getElementById('wsLogContainer');
                if (!container) return;

                const entry = document.createElement('div');
                let entryClass = 'mini-log-entry';
                let direction = '';

                switch (type) {
                    case 'open':
                        entryClass += ' ws-open';
                        break;
                    case 'close':
                        entryClass += ' ws-close';
                        break;
                    case 'sent':
                        entryClass += ' ws-message';
                        direction = '<span class="ws-direction sent">&#8593;</span>';
                        break;
                    case 'recv':
                        entryClass += ' ws-message';
                        direction = '<span class="ws-direction received">&#8595;</span>';
                        break;
                    case 'error':
                        entryClass += ' ws-error';
                        break;
                    case 'zombie':
                        entryClass += ' ws-zombie';
                        break;
                }

                entry.className = entryClass;
                entry.innerHTML =
                    '<div class="mini-log-time">' + timestamp + ' [WS#' + wsId + ']</div>' +
                    '<div class="mini-log-msg">' + direction + type + '</div>' +
                    (data ? '<div class="mini-log-data">' + this.escapeHtml(JSON.stringify(data)) + '</div>' : '');

                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;

                // Limit log entries
                while (container.children.length > 100) {
                    container.removeChild(container.firstChild);
                }

                // Also log important events to main panel
                if (['open', 'close', 'error', 'zombie'].includes(type)) {
                    debugTools.addLog('events', 'WS#' + wsId + ' ' + type, data,
                        type === 'error' || type === 'zombie' ? 'error' :
                        type === 'close' ? 'warn' : 'success');
                }
            },

            updateWsUI: function() {
                const activeCount = [...this.websockets.values()].filter(w => w.state === 'open').length;
                const zombieCount = [...this.websockets.values()].filter(w => w.markedZombie).length;
                const totalMsgs = this.wsTotalMessages.sent + this.wsTotalMessages.received;

                document.getElementById('wsActiveCount').textContent = activeCount;
                document.getElementById('wsTotalOpened').textContent = this.wsTotalOpened;
                document.getElementById('wsMsgsSent').textContent = this.wsTotalMessages.sent;
                document.getElementById('wsMsgsReceived').textContent = this.wsTotalMessages.received;
                document.getElementById('wsZombieCount').textContent = zombieCount;

                // Update summary badges
                document.getElementById('wsConnBadge').textContent = activeCount + ' active';
                document.getElementById('wsMsgBadge').textContent = totalMsgs + ' msgs';

                // Update status dot
                const statusDot = document.getElementById('wsStatusDot');
                if (zombieCount > 0) {
                    statusDot.className = 'section-status warning';
                } else if (activeCount > 0) {
                    statusDot.className = 'section-status';
                } else {
                    statusDot.className = 'section-status unknown';
                }
            },

            // ========================================
            // Visibility Tracking
            // ========================================

            initVisibilityTracking: function() {
                const self = this;

                document.addEventListener('visibilitychange', function() {
                    const now = Date.now();
                    const prevState = self.visibilityState;
                    const newState = document.visibilityState;
                    const duration = now - self.lastVisibilityChange;

                    // Update time counters
                    if (prevState === 'visible') {
                        self.timeVisible += duration;
                    } else {
                        self.timeHidden += duration;
                    }

                    self.visibilityState = newState;
                    self.lastVisibilityChange = now;
                    self.visibilityTransitions++;

                    const activeWs = [...self.websockets.values()].filter(w => w.state === 'open').length;

                    const eventData = {
                        from: prevState,
                        to: newState,
                        duration: Math.round(duration / 1000) + 's',
                        activeWS: activeWs
                    };

                    self.logVisibilityEvent(newState, eventData);
                    self.updateVisibilityUI();

                    // Log to main panel
                    if (newState === 'hidden') {
                        debugTools.addLog('events', 'Page hidden - monitoring WebSockets', { activeWS: activeWs }, 'warn');
                    } else {
                        debugTools.addLog('events', 'Page visible', { activeWS: activeWs }, 'info');
                    }
                });

                this.updateVisibilityUI();
                setInterval(() => this.updateVisibilityUI(), 1000);
            },

            logVisibilityEvent: function(state, data) {
                const timestamp = new Date().toLocaleTimeString();
                const container = document.getElementById('visLogContainer');
                if (!container) return;

                const entry = document.createElement('div');
                entry.className = 'mini-log-entry vis-' + state;
                entry.innerHTML =
                    '<div class="mini-log-time">' + timestamp + '</div>' +
                    '<div class="mini-log-msg">State: ' + state + '</div>' +
                    '<div class="mini-log-data">' + this.escapeHtml(JSON.stringify(data)) + '</div>';

                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;

                while (container.children.length > 50) {
                    container.removeChild(container.firstChild);
                }
            },

            updateVisibilityUI: function() {
                const now = Date.now();
                const currentDuration = now - this.lastVisibilityChange;

                let totalVisible = this.timeVisible;
                let totalHidden = this.timeHidden;

                if (this.visibilityState === 'visible') {
                    totalVisible += currentDuration;
                } else {
                    totalHidden += currentDuration;
                }

                document.getElementById('visCurrentState').textContent = this.visibilityState;
                document.getElementById('visTimeVisible').textContent = this.formatDuration(totalVisible);
                document.getElementById('visTimeHidden').textContent = this.formatDuration(totalHidden);
                document.getElementById('visTransitions').textContent = this.visibilityTransitions;

                // Update summary
                const stateBadge = document.getElementById('visStateBadge');
                stateBadge.textContent = this.visibilityState === 'visible' ? 'Visible' : 'Hidden';
                stateBadge.className = 'metric-badge ' + this.visibilityState;

                // Update status dot
                const statusDot = document.getElementById('visStatusDot');
                statusDot.className = this.visibilityState === 'visible' ?
                    'section-status' : 'section-status warning';
            },

            formatDuration: function(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const hours = Math.floor(minutes / 60);

                if (hours > 0) {
                    return hours + 'h ' + (minutes % 60) + 'm';
                } else if (minutes > 0) {
                    return minutes + 'm ' + (seconds % 60) + 's';
                } else {
                    return seconds + 's';
                }
            },

            // ========================================
            // Network Status Tracking
            // ========================================

            initNetworkTracking: function() {
                const self = this;

                this.updateNetworkUI();

                window.addEventListener('online', function() {
                    self.networkTransitions++;
                    self.logNetworkEvent('online', { time: new Date().toLocaleTimeString() });
                    self.updateNetworkUI();
                    debugTools.addLog('events', 'Network: Back online', null, 'success');
                });

                window.addEventListener('offline', function() {
                    self.networkTransitions++;
                    const activeWs = [...self.websockets.values()].filter(w => w.state === 'open').length;
                    self.logNetworkEvent('offline', { activeWS: activeWs });
                    self.updateNetworkUI();
                    debugTools.addLog('events', 'Network: Went offline', { activeWS: activeWs }, 'error');
                    statusOrb.logError();
                });

                if ('connection' in navigator) {
                    navigator.connection.addEventListener('change', function() {
                        self.updateNetworkUI();
                    });
                }
            },

            logNetworkEvent: function(type, data) {
                const timestamp = new Date().toLocaleTimeString();
                const container = document.getElementById('netLogContainer');
                if (!container) return;

                const entry = document.createElement('div');
                entry.className = 'mini-log-entry net-' + type;
                entry.innerHTML =
                    '<div class="mini-log-time">' + timestamp + '</div>' +
                    '<div class="mini-log-msg">Network: ' + type + '</div>' +
                    (data ? '<div class="mini-log-data">' + this.escapeHtml(JSON.stringify(data)) + '</div>' : '');

                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
            },

            updateNetworkUI: function() {
                const isOnline = navigator.onLine;

                const statusEl = document.getElementById('netCurrentStatus');
                statusEl.textContent = isOnline ? 'Online' : 'Offline';
                statusEl.className = 'config-value ' + (isOnline ? 'online' : 'offline');

                if ('connection' in navigator) {
                    document.getElementById('netConnectionType').textContent =
                        navigator.connection.type || 'unknown';
                    document.getElementById('netEffectiveType').textContent =
                        navigator.connection.effectiveType || 'unknown';
                } else {
                    document.getElementById('netConnectionType').textContent = 'N/A';
                    document.getElementById('netEffectiveType').textContent = 'N/A';
                }

                document.getElementById('netTransitions').textContent = this.networkTransitions;

                // Update summary
                const statusBadge = document.getElementById('netStateBadge');
                statusBadge.textContent = isOnline ? 'Online' : 'Offline';
                statusBadge.className = 'metric-badge ' + (isOnline ? 'online' : 'offline');

                // Update status dot
                const statusDot = document.getElementById('netStatusDot');
                statusDot.className = isOnline ? 'section-status' : 'section-status error';
            },

            // ========================================
            // Browser Detection
            // ========================================

            detectBrowser: function() {
                const ua = navigator.userAgent;
                const info = {
                    browser: 'Unknown',
                    version: 'Unknown',
                    platform: navigator.platform || 'Unknown',
                    isSafari: false,
                    isIOS: false,
                    iosVersion: null,
                    safariVersion: null,
                    hasWebKitBug: false,
                    isIframe: window !== window.top,
                    hasITPRestrictions: false
                };

                // Detect Safari
                const safariMatch = ua.match(/Version\/(\d+\.?\d*).* Safari/);
                if (safariMatch && !ua.includes('Chrome') && !ua.includes('Chromium')) {
                    info.browser = 'Safari';
                    info.version = safariMatch[1];
                    info.safariVersion = parseFloat(safariMatch[1]);
                    info.isSafari = true;

                    if (info.safariVersion < 17.3) {
                        info.hasWebKitBug = true;
                    }
                }

                // Detect iOS
                if (/iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) {
                    info.isIOS = true;
                    const iosMatch = ua.match(/OS (\d+)_(\d+)/);
                    if (iosMatch) {
                        info.iosVersion = iosMatch[1] + '.' + iosMatch[2];
                    }
                }

                // Detect other browsers
                if (!info.isSafari) {
                    const chromeMatch = ua.match(/Chrome\/(\d+)/);
                    if (chromeMatch) {
                        info.browser = 'Chrome';
                        info.version = chromeMatch[1];
                    }

                    const firefoxMatch = ua.match(/Firefox\/(\d+)/);
                    if (firefoxMatch) {
                        info.browser = 'Firefox';
                        info.version = firefoxMatch[1];
                    }

                    const edgeMatch = ua.match(/Edg\/(\d+)/);
                    if (edgeMatch) {
                        info.browser = 'Edge';
                        info.version = edgeMatch[1];
                    }
                }

                if (info.isIframe && info.isSafari) {
                    info.hasITPRestrictions = true;
                }

                this.browserInfo = info;
                this.updateBrowserUI();

                if (info.hasWebKitBug) {
                    debugTools.addLog('events', 'Safari WebKit bug #247943 detected', {
                        version: info.safariVersion,
                        note: 'WebSocket may drop when hidden'
                    }, 'warn');
                    statusOrb.logWarning();
                }

                if (info.hasITPRestrictions) {
                    debugTools.addLog('events', 'Safari ITP: Running in iframe', {
                        note: 'Storage may be restricted'
                    }, 'warn');
                }
            },

            updateBrowserUI: function() {
                const info = this.browserInfo;

                document.getElementById('browserDetected').textContent = info.browser;
                document.getElementById('browserVersion').textContent = info.version;
                document.getElementById('browserPlatform').textContent = info.platform;
                document.getElementById('iosVersion').textContent = info.iosVersion || 'N/A';

                // Update summary
                document.getElementById('browserBadge').textContent =
                    info.browser + ' ' + info.version;

                if (info.hasWebKitBug) {
                    document.getElementById('webkitBugWarning').style.display = 'flex';
                }

                if (info.hasITPRestrictions) {
                    document.getElementById('itpWarning').style.display = 'flex';
                }

                // Update status dot
                const statusDot = document.getElementById('browserStatusDot');
                if (info.hasWebKitBug || info.hasITPRestrictions) {
                    statusDot.className = 'section-status warning';
                } else {
                    statusDot.className = 'section-status';
                }
            },

            // ========================================
            // Storage Diagnostics
            // ========================================

            runStorageTest: function() {
                const self = this;
                const results = {
                    localStorage: this.testLocalStorage(),
                    sessionStorage: this.testSessionStorage(),
                    cookies: this.testCookies(),
                    indexedDB: { available: false, status: 'Testing...' },
                    context: this.detectStorageContext()
                };

                this.testIndexedDB().then(function(result) {
                    results.indexedDB = result;
                    self.storageResults = results;
                    self.updateStorageUI();
                });

                this.storageResults = results;
                this.updateStorageUI();
            },

            testLocalStorage: function() {
                try {
                    const testKey = '__widgetscope_test__';
                    localStorage.setItem(testKey, 'test');
                    localStorage.removeItem(testKey);
                    return { available: true, status: 'OK' };
                } catch (e) {
                    return { available: false, status: 'Blocked' };
                }
            },

            testSessionStorage: function() {
                try {
                    const testKey = '__widgetscope_test__';
                    sessionStorage.setItem(testKey, 'test');
                    sessionStorage.removeItem(testKey);
                    return { available: true, status: 'OK' };
                } catch (e) {
                    return { available: false, status: 'Blocked' };
                }
            },

            testCookies: function() {
                try {
                    document.cookie = '__widgetscope_test__=1; SameSite=Lax';
                    const hasCookie = document.cookie.includes('__widgetscope_test__');
                    document.cookie = '__widgetscope_test__=; expires=Thu, 01 Jan 1970 00:00:00 GMT';
                    return { available: hasCookie, status: hasCookie ? 'OK' : 'Blocked' };
                } catch (e) {
                    return { available: false, status: 'Error' };
                }
            },

            testIndexedDB: function() {
                return new Promise(function(resolve) {
                    try {
                        const request = indexedDB.open('__widgetscope_test__');
                        request.onerror = function() {
                            resolve({ available: false, status: 'Blocked' });
                        };
                        request.onsuccess = function() {
                            request.result.close();
                            indexedDB.deleteDatabase('__widgetscope_test__');
                            resolve({ available: true, status: 'OK' });
                        };
                    } catch (e) {
                        resolve({ available: false, status: 'Error' });
                    }
                });
            },

            detectStorageContext: function() {
                const isIframe = window !== window.top;
                const isCrossOrigin = isIframe && (function() {
                    try {
                        return !window.top.location.href;
                    } catch (e) {
                        return true;
                    }
                })();

                if (isCrossOrigin) {
                    return '3rd-party iframe';
                } else if (isIframe) {
                    return 'Same-origin iframe';
                } else {
                    return 'Top-level';
                }
            },

            updateStorageUI: function() {
                const results = this.storageResults;
                if (!results) return;

                const setStatus = function(id, result) {
                    const el = document.getElementById(id);
                    if (!el) return;
                    el.textContent = result.status;
                    el.className = 'config-value ' + (result.available ? 'success' : 'warning');
                };

                setStatus('localStorageStatus', results.localStorage);
                setStatus('sessionStorageStatus', results.sessionStorage);
                setStatus('cookieStatus', results.cookies);
                setStatus('indexedDBStatus', results.indexedDB);

                document.getElementById('storageContext').textContent = results.context;

                // Update summary
                const allOk = results.localStorage.available &&
                              results.sessionStorage.available &&
                              results.cookies.available;

                const statusBadge = document.getElementById('storageBadge');
                statusBadge.textContent = allOk ? 'All OK' : 'Issues';
                statusBadge.className = 'metric-badge ' + (allOk ? 'online' : 'warning');

                // Update status dot
                const statusDot = document.getElementById('storageStatusDot');
                statusDot.className = allOk ? 'section-status' : 'section-status warning';

                if (!allOk) {
                    debugTools.addLog('events', 'Storage access issues', results, 'warn');
                }
            },

            // ========================================
            // MQTT Protocol Parser & Monitor
            // ========================================

            // MQTT packet type constants
            MQTT_PACKET_TYPES: {
                1: 'CONNECT',
                2: 'CONNACK',
                3: 'PUBLISH',
                4: 'PUBACK',
                5: 'PUBREC',
                6: 'PUBREL',
                7: 'PUBCOMP',
                8: 'SUBSCRIBE',
                9: 'SUBACK',
                10: 'UNSUBSCRIBE',
                11: 'UNSUBACK',
                12: 'PINGREQ',
                13: 'PINGRESP',
                14: 'DISCONNECT',
                15: 'AUTH'
            },

            // Detect if a WebSocket URL is likely MQTT
            isMqttUrl: function(url) {
                const mqttPatterns = [
                    /mqtt/i,
                    /wss?:\/\/[^\/]*:\d*(443|8083|8084|8883|1883)/,
                    /imi.*connect/i,
                    /webex.*connect/i,
                    /message.*broker/i
                ];
                return mqttPatterns.some(p => p.test(url));
            },

            // Parse MQTT packet from binary data
            parseMqttPacket: function(data) {
                try {
                    let bytes;
                    if (data instanceof ArrayBuffer) {
                        bytes = new Uint8Array(data);
                    } else if (data instanceof Uint8Array) {
                        bytes = data;
                    } else if (typeof data === 'string') {
                        // Try to detect if it's binary disguised as string
                        if (data.length >= 2) {
                            const firstByte = data.charCodeAt(0);
                            const packetType = (firstByte >> 4) & 0x0F;
                            if (packetType >= 1 && packetType <= 15) {
                                bytes = new Uint8Array(data.length);
                                for (let i = 0; i < data.length; i++) {
                                    bytes[i] = data.charCodeAt(i) & 0xFF;
                                }
                            } else {
                                return null; // Not MQTT
                            }
                        } else {
                            return null;
                        }
                    } else {
                        return null;
                    }

                    if (bytes.length < 2) return null;

                    const firstByte = bytes[0];
                    const packetType = (firstByte >> 4) & 0x0F;
                    const flags = firstByte & 0x0F;

                    if (packetType < 1 || packetType > 15) return null;

                    const typeName = this.MQTT_PACKET_TYPES[packetType] || 'UNKNOWN';

                    // Decode remaining length (variable byte integer)
                    let remainingLength = 0;
                    let multiplier = 1;
                    let pos = 1;
                    let encodedByte;

                    do {
                        if (pos >= bytes.length) return null;
                        encodedByte = bytes[pos++];
                        remainingLength += (encodedByte & 127) * multiplier;
                        multiplier *= 128;
                        if (multiplier > 128 * 128 * 128) return null;
                    } while ((encodedByte & 128) !== 0);

                    const packet = {
                        type: packetType,
                        typeName: typeName,
                        flags: flags,
                        remainingLength: remainingLength,
                        raw: bytes
                    };

                    // Parse specific packet types
                    const payloadStart = pos;
                    const payload = bytes.slice(payloadStart);

                    switch (packetType) {
                        case 1: // CONNECT
                            packet.details = this.parseConnect(payload);
                            break;
                        case 2: // CONNACK
                            packet.details = this.parseConnack(payload);
                            break;
                        case 3: // PUBLISH
                            packet.details = this.parsePublish(payload, flags);
                            break;
                        case 8: // SUBSCRIBE
                            packet.details = this.parseSubscribe(payload);
                            break;
                        case 9: // SUBACK
                            packet.details = this.parseSuback(payload);
                            break;
                        case 12: // PINGREQ
                        case 13: // PINGRESP
                            packet.details = { note: 'Keep-alive' };
                            break;
                        case 14: // DISCONNECT
                            packet.details = { note: 'Connection closing' };
                            break;
                    }

                    return packet;
                } catch (e) {
                    console.warn('MQTT parse error:', e);
                    return null;
                }
            },

            parseConnect: function(payload) {
                try {
                    // Protocol name length (2 bytes) + protocol name
                    const protoNameLen = (payload[0] << 8) | payload[1];
                    const protoName = String.fromCharCode.apply(null, payload.slice(2, 2 + protoNameLen));
                    const pos = 2 + protoNameLen;

                    const protoVersion = payload[pos];
                    const connectFlags = payload[pos + 1];
                    const keepAlive = (payload[pos + 2] << 8) | payload[pos + 3];

                    // Client ID starts after variable header
                    let clientIdPos = pos + 4;
                    const clientIdLen = (payload[clientIdPos] << 8) | payload[clientIdPos + 1];
                    clientIdPos += 2;
                    const clientId = String.fromCharCode.apply(null, payload.slice(clientIdPos, clientIdPos + clientIdLen));

                    return {
                        protocol: protoName,
                        version: protoVersion,
                        keepAlive: keepAlive,
                        clientId: clientId.substring(0, 30) + (clientId.length > 30 ? '...' : ''),
                        cleanSession: !!(connectFlags & 0x02)
                    };
                } catch (e) {
                    return { error: 'Parse failed' };
                }
            },

            parseConnack: function(payload) {
                try {
                    const sessionPresent = !!(payload[0] & 0x01);
                    const returnCode = payload[1];
                    const returnCodes = {
                        0: 'Accepted',
                        1: 'Unacceptable protocol',
                        2: 'Identifier rejected',
                        3: 'Server unavailable',
                        4: 'Bad credentials',
                        5: 'Not authorized'
                    };
                    return {
                        sessionPresent: sessionPresent,
                        returnCode: returnCode,
                        status: returnCodes[returnCode] || 'Unknown'
                    };
                } catch (e) {
                    return { error: 'Parse failed' };
                }
            },

            parsePublish: function(payload, flags) {
                try {
                    const qos = (flags >> 1) & 0x03;
                    const retain = !!(flags & 0x01);
                    const dup = !!(flags & 0x08);

                    // Topic name
                    const topicLen = (payload[0] << 8) | payload[1];
                    const topic = String.fromCharCode.apply(null, payload.slice(2, 2 + topicLen));

                    let pos = 2 + topicLen;

                    // Packet ID (only for QoS > 0)
                    let packetId = null;
                    if (qos > 0 && payload.length > pos + 1) {
                        packetId = (payload[pos] << 8) | payload[pos + 1];
                        pos += 2;
                    }

                    // Payload
                    const messagePayload = payload.slice(pos);
                    let payloadStr;
                    try {
                        payloadStr = new TextDecoder().decode(messagePayload);
                        // Try to parse as JSON
                        try {
                            const json = JSON.parse(payloadStr);
                            payloadStr = JSON.stringify(json).substring(0, 100);
                        } catch (e) {
                            payloadStr = payloadStr.substring(0, 100);
                        }
                    } catch (e) {
                        payloadStr = '[Binary: ' + messagePayload.length + ' bytes]';
                    }

                    return {
                        topic: topic,
                        qos: qos,
                        retain: retain,
                        dup: dup,
                        packetId: packetId,
                        payload: payloadStr + (payloadStr.length >= 100 ? '...' : '')
                    };
                } catch (e) {
                    return { error: 'Parse failed' };
                }
            },

            parseSubscribe: function(payload) {
                try {
                    // Packet ID
                    const packetId = (payload[0] << 8) | payload[1];
                    let pos = 2;

                    const topics = [];
                    while (pos < payload.length) {
                        const topicLen = (payload[pos] << 8) | payload[pos + 1];
                        pos += 2;
                        const topic = String.fromCharCode.apply(null, payload.slice(pos, pos + topicLen));
                        pos += topicLen;
                        const qos = payload[pos++];
                        topics.push({ topic: topic, qos: qos });
                    }

                    return {
                        packetId: packetId,
                        topics: topics.map(t => t.topic + ' (QoS ' + t.qos + ')').join(', ')
                    };
                } catch (e) {
                    return { error: 'Parse failed' };
                }
            },

            parseSuback: function(payload) {
                try {
                    const packetId = (payload[0] << 8) | payload[1];
                    const returnCodes = Array.from(payload.slice(2)).map(c =>
                        c === 0x80 ? 'Failure' : 'QoS ' + c
                    );
                    return {
                        packetId: packetId,
                        results: returnCodes.join(', ')
                    };
                } catch (e) {
                    return { error: 'Parse failed' };
                }
            },

            // Process WebSocket message for MQTT
            processMqttMessage: function(wsId, data, direction) {
                const packet = this.parseMqttPacket(data);
                if (!packet) return false;

                // Track connection in MQTT map
                if (!this.mqttConnections.has(wsId)) {
                    this.mqttConnections.set(wsId, {
                        wsId: wsId,
                        state: 'connecting',
                        clientId: null,
                        broker: null,
                        topics: new Set()
                    });
                }

                const conn = this.mqttConnections.get(wsId);

                // Update stats based on packet type
                switch (packet.typeName) {
                    case 'CONNECT':
                        this.mqttStats.connections++;
                        conn.state = 'connecting';
                        if (packet.details && packet.details.clientId) {
                            conn.clientId = packet.details.clientId;
                        }
                        this.mqttState = 'connecting';
                        break;

                    case 'CONNACK':
                        if (packet.details && packet.details.returnCode === 0) {
                            conn.state = 'connected';
                            this.mqttState = 'connected';
                            debugTools.addLog('events', 'MQTT connected', packet.details, 'success');
                        } else {
                            conn.state = 'failed';
                            this.mqttState = 'disconnected';
                            debugTools.addLog('events', 'MQTT connection failed', packet.details, 'error');
                            statusOrb.logError();
                        }
                        break;

                    case 'PUBLISH':
                        if (direction === 'sent') {
                            this.mqttStats.published++;
                        } else {
                            this.mqttStats.received++;
                        }
                        if (packet.details && packet.details.topic) {
                            this.mqttStats.topics.add(packet.details.topic);
                            conn.topics.add(packet.details.topic);
                        }
                        break;

                    case 'SUBSCRIBE':
                        this.mqttStats.subscribes++;
                        break;

                    case 'PINGREQ':
                    case 'PINGRESP':
                        this.mqttStats.pings++;
                        break;

                    case 'DISCONNECT':
                        conn.state = 'disconnected';
                        this.mqttState = 'disconnected';
                        debugTools.addLog('events', 'MQTT disconnected', null, 'warn');
                        break;
                }

                this.logMqttEvent(wsId, packet, direction);
                this.updateMqttUI();

                return true;
            },

            logMqttEvent: function(wsId, packet, direction) {
                const timestamp = new Date().toLocaleTimeString();
                const container = document.getElementById('mqttLogContainer');
                if (!container) return;

                const entry = document.createElement('div');
                let entryClass = 'mini-log-entry mqtt-' + packet.typeName.toLowerCase();

                const dirIcon = direction === 'sent' ? '' : '';
                const dirClass = direction === 'sent' ? 'sent' : 'received';

                let detailsHtml = '';
                if (packet.details) {
                    if (packet.details.topic) {
                        detailsHtml += '<div class="mqtt-topic">' + this.escapeHtml(packet.details.topic) + '</div>';
                    }
                    if (packet.details.payload) {
                        detailsHtml += '<div class="mqtt-payload-preview">' + this.escapeHtml(packet.details.payload) + '</div>';
                    }
                    if (packet.details.clientId) {
                        detailsHtml += '<div class="mini-log-data">Client: ' + this.escapeHtml(packet.details.clientId) + '</div>';
                    }
                    if (packet.details.status) {
                        detailsHtml += '<div class="mini-log-data">' + this.escapeHtml(packet.details.status) + '</div>';
                    }
                    if (packet.details.topics) {
                        detailsHtml += '<div class="mini-log-data">Topics: ' + this.escapeHtml(packet.details.topics) + '</div>';
                    }
                }

                entry.className = entryClass;
                entry.innerHTML =
                    '<div class="mini-log-time">' + timestamp + '</div>' +
                    '<div class="mini-log-msg">' +
                    '<span class="ws-direction ' + dirClass + '">' + dirIcon + '</span>' +
                    '<span class="mqtt-packet-type ' + packet.typeName.toLowerCase() + '">' + packet.typeName + '</span>' +
                    (packet.details && packet.details.qos !== undefined ? '<span class="mqtt-qos">QoS ' + packet.details.qos + '</span>' : '') +
                    '</div>' +
                    detailsHtml;

                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
            },

            updateMqttUI: function() {
                // Connection count
                document.getElementById('mqttConnCount').textContent = this.mqttStats.connections;
                document.getElementById('mqttPubCount').textContent = this.mqttStats.published;
                document.getElementById('mqttRecvCount').textContent = this.mqttStats.received;
                document.getElementById('mqttSubCount').textContent = this.mqttStats.subscribes;
                document.getElementById('mqttPingCount').textContent = this.mqttStats.pings;

                // Connection state indicator
                const indicator = document.getElementById('mqttConnIndicator');
                const stateText = document.getElementById('mqttConnState');

                indicator.className = 'mqtt-connection-indicator ' + this.mqttState;
                stateText.textContent = this.mqttState === 'connected' ? 'Connected' :
                                        this.mqttState === 'connecting' ? 'Connecting...' : 'Not detected';

                // Summary badges
                const connBadge = document.getElementById('mqttConnBadge');
                if (this.mqttState === 'connected') {
                    connBadge.textContent = 'Connected';
                    connBadge.className = 'metric-badge online';
                } else if (this.mqttState === 'connecting') {
                    connBadge.textContent = 'Connecting';
                    connBadge.className = 'metric-badge warning';
                } else if (this.mqttStats.connections > 0) {
                    connBadge.textContent = 'Disconnected';
                    connBadge.className = 'metric-badge offline';
                } else {
                    connBadge.textContent = 'No MQTT';
                    connBadge.className = 'metric-badge';
                }

                const msgTotal = this.mqttStats.published + this.mqttStats.received;
                document.getElementById('mqttMsgBadge').textContent = msgTotal + ' msgs';

                // Status dot
                const statusDot = document.getElementById('mqttStatusDot');
                if (this.mqttState === 'connected') {
                    statusDot.className = 'section-status';
                } else if (this.mqttState === 'connecting' || this.mqttStats.connections > 0) {
                    statusDot.className = 'section-status warning';
                } else {
                    statusDot.className = 'section-status';
                }

                // Broker URL (from first active connection)
                const activeConn = [...this.mqttConnections.values()].find(c => c.state === 'connected');
                if (activeConn && activeConn.broker) {
                    document.getElementById('mqttBrokerUrl').textContent = activeConn.broker;
                }
            },

            onMqttWsClose: function(wsId) {
                const conn = this.mqttConnections.get(wsId);
                if (conn) {
                    conn.state = 'disconnected';
                    // Check if any MQTT connections still active
                    const anyActive = [...this.mqttConnections.values()].some(c => c.state === 'connected');
                    if (!anyActive) {
                        this.mqttState = 'disconnected';
                    }
                    this.updateMqttUI();
                }
            },

            // Utility
            escapeHtml: function(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            // Get data for export
            getExportData: function() {
                return {
                    browser: this.browserInfo,
                    websockets: {
                        totalOpened: this.wsTotalOpened,
                        activeCount: [...this.websockets.values()].filter(w => w.state === 'open').length,
                        messages: this.wsTotalMessages,
                        zombiesDetected: [...this.websockets.values()].filter(w => w.markedZombie).length
                    },
                    mqtt: {
                        state: this.mqttState,
                        connections: this.mqttStats.connections,
                        published: this.mqttStats.published,
                        received: this.mqttStats.received,
                        subscribes: this.mqttStats.subscribes,
                        pings: this.mqttStats.pings,
                        topics: [...this.mqttStats.topics],
                        activeConnections: [...this.mqttConnections.values()].filter(c => c.state === 'connected').length
                    },
                    visibility: {
                        state: this.visibilityState,
                        transitions: this.visibilityTransitions,
                        timeVisible: this.formatDuration(this.timeVisible),
                        timeHidden: this.formatDuration(this.timeHidden)
                    },
                    storage: this.storageResults,
                    network: {
                        online: navigator.onLine,
                        transitions: this.networkTransitions
                    }
                };
            },

            // Clear mini-logs
            clearLogs: function() {
                ['wsLogContainer', 'visLogContainer', 'netLogContainer', 'mqttLogContainer'].forEach(function(id) {
                    const el = document.getElementById(id);
                    if (el) el.innerHTML = '';
                });
            }
        };

        // Initialize Safari debug tools
        setTimeout(function() { safariDebug.init(); }, 100);

        // Initialize
        debugTools.addLog('events', 'Dashboard ready', { session: sessionUUID }, 'success');
        initWidget();

        // Help Panel Controller
        const helpPanel = {
            panel: document.getElementById('helpPanel'),
            overlay: document.getElementById('helpOverlay'),

            toggle: function() {
                if (this.panel.classList.contains('show')) {
                    this.close();
                } else {
                    this.open();
                }
            },

            open: function() {
                this.panel.classList.add('show');
                this.overlay.classList.add('show');
                document.body.style.overflow = 'hidden';
            },

            close: function() {
                this.panel.classList.remove('show');
                this.overlay.classList.remove('show');
                document.body.style.overflow = '';
            },

            navigateTo: function(sectionId) {
                // Update nav items
                document.querySelectorAll('.help-nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                document.querySelector(`.help-nav-item[data-section="${sectionId}"]`)?.classList.add('active');

                // Update sections
                document.querySelectorAll('.help-section').forEach(section => {
                    section.classList.remove('active');
                });
                document.getElementById(`section-${sectionId}`)?.classList.add('active');

                // Scroll content to top
                document.querySelector('.help-content').scrollTop = 0;
            },

            exportDocs: function() {
                const markdown = `# Webex Connect Widget Debug Dashboard - Documentation

*Exported on ${new Date().toLocaleString()}*

---

## Overview

This dashboard provides real-time debugging and monitoring tools for Webex Connect (IMI Chat) chatbot widgets. Use it to inspect widget communication, troubleshoot issues, and understand how your chatbot interacts with web pages.

### Dashboard Layout
- **Left Sidebar** - Widget status, session info, filters, and widget configuration details
- **Console Logs** - Captures all JavaScript console output from the page
- **PostMessages** - Shows cross-origin communication between the widget iframe and parent page
- **Network & Events** - Tracks HTTP requests and widget lifecycle events

> **Tip:** The right 25% of the screen is reserved for the chatbot widget. You can interact with the chatbot while viewing debug information.

---

## Dashboard Tools

### Sidebar Controls

#### Reload Widget
Removes the current widget instance and reinitializes it. Useful for testing initialization sequences or recovering from errors.

#### Clear
Clears all logged data from every panel.

#### Export
Downloads all captured logs as a JSON file.

### Quick Actions

| Button | Description |
|--------|-------------|
| **Inspect** | Logs current widget state to Events panel |
| **Ping** | Tests connectivity to IMI servers |
| **Full Report** | Copies comprehensive JSON report to clipboard |
| **Copy Config** | Copies widget configuration JSON |

### Filter Controls
- **Hide React DevTools noise** - Filters browser extension messages
- **Hide debug_panel test msgs** - Filters dashboard's own test messages
- **Collapse repeated messages** - Groups identical consecutive messages

---

## IMI Chat Widget SDK Methods

The Webex Engage LiveChat widget exposes JavaScript SDK methods on the global \`imichatwidget\` object.

### imichatwidget.show()
Displays the chat widget.

\`\`\`javascript
document.getElementById('chatBtn').onclick = function() {
    imichatwidget.show();
};
\`\`\`

### imichatwidget.hide()
Hides the chat widget from view.

### imichatwidget.init(data, callback)
Initializes the widget with custom data.

\`\`\`javascript
var data = JSON.stringify({
    "custom_chat_fields": {
        "Customer ID": "12345",
        "Plan Type": "Premium"
    }
});

imichatwidget.init(data, function(response) {
    console.log('Widget initialized', response);
});
\`\`\`

> **Note:** Custom field keys must be configured in the Webex Engage Admin Console before use.

### imichatwidget.update(data, callback)
Updates custom chat fields after initialization.

### imichatwidget.on(event, callback)
Subscribe to widget events.

\`\`\`javascript
imichatwidget.on("imichat-widget:ready", function(appId) {
    console.log('Widget ready, App ID:', appId);
    imichatwidget.show();
});
\`\`\`

### imichatwidget.maximizeWindow()
Expands the chat widget to its maximized state.

### imichatwidget.minimizeWindow()
Minimizes the chat widget to its collapsed state.

---

## Widget Configuration

### Configuration Fields

| Field | Description |
|-------|-------------|
| \`appid\` | Unique application identifier |
| \`name\` | Display name for the widget |
| \`website_id\` | ID of the registered website |
| \`agent_avail\` | Agent availability (1=yes, 0=no) |
| \`enable_proactive\` | Proactive chat enabled |
| \`isattachmentenabled\` | File attachments allowed |
| \`isemojienable\` | Emoji picker available |
| \`widget_lang\` | Language code |
| \`widgetcolor\` | Primary color (hex) |

### Installation

\`\`\`html
<!-- Widget container -->
<div id="divicw"
     data-bind="YOUR-BIND-ID"
     data-guid="YOUR-WIDGET-GUID"></div>

<!-- Widget script -->
<scr` + `ipt src="https://media.imi.chat/widget/js/imichatinit.js"></scr` + `ipt>
\`\`\`

### Domain Whitelisting
Configure in General Settings without http/https prefix:
- \`*.example.com\` - All subdomains
- \`www.example.com\` - Specific subdomain
- \`example.com\` - Root domain only

---

## Troubleshooting Guide

### Widget Not Appearing

**Check Console Logs:**
- 404 on imichatinit.js  Verify script URL
- CORS errors  Domain not whitelisted
- No errors  Check divicw element exists

**Check PostMessages:**
- No messages from imi.chat  Script didn't load
- No loadstyles action  Check GUID and bind ID

### Widget Loads But Chat Fails
- \`agent_avail = 0\`  No agents online
- Connection timeout  Check WebSocket connections
- Blank chat window  Bot configuration issue

### Debug Checklist
1. Is \`divicw\` present with correct \`data-bind\` and \`data-guid\`?
2. Is the script loading from \`media.imi.chat\`?
3. Does the domain match whitelist configuration?
4. Are there JavaScript errors in console?
5. Is \`loadstyles\` PostMessage received?
6. What does \`agent_avail\` show in config?
7. Can you ping the IMI servers successfully?

---

## PostMessage API

### Message Structure
\`\`\`json
{
    "action": "actionName",
    "message": "...",
    "key": "...",
    "value": "..."
}
\`\`\`

### Common Actions

| Action | Description |
|--------|-------------|
| \`loadstyles\` | Widget configuration payload |
| \`setlocal\` | Widget storing data in localStorage |
| \`getlocal\` | Widget retrieving from localStorage |
| \`resize\` | Widget requesting size change |
| \`maximize\` | Widget expanding to full view |
| \`minimize\` | Widget collapsing to launcher |

---

## Common Issues Reference

### Error: Widget GUID Not Found
**Cause:** data-guid doesn't match any registered widget
**Solution:** Verify GUID in Webex Engage Admin Console

### Error: Domain Not Whitelisted
**Cause:** Current domain isn't in allowed list
**Solution:** Add domain pattern in Admin Console

### Warning: IMIchat is undefined
**Cause:** Calling methods before script loads
**Solution:** Wait for \`imichat-widget:ready\` event

### Issue: Bot Not Responding
**Possible causes:**
- Flow not published in Webex Connect
- Bot integration webhook URL incorrect
- Error in bot flow logic
- Service account permissions

---

## External Resources

### Official Documentation
- [Webex Engage Developer Guide](https://docs.imi.chat/reference/introduction)
- [LiveChat Channel Setup](https://docs.imi.chat/docs/livechat-channel)
- [Webex Connect Overview](https://developer.webex.com/docs/webex-connect)
- [IMI Connect API Docs](https://developers.imiconnect.io/)

### SDK Reference
- [imichatwidget.show()](https://docs.imi.chat/reference/imichatwidgetshow)
- [imichatwidget.init()](https://docs.imi.chat/reference/imichatwidgetinit)
- [imichatwidget.update()](https://docs.imi.chat/reference/imichatwidgetupdate)
- [imichatwidget.on()](https://docs.imi.chat/reference/imichatwidgetonimichat-widgetready-func)

### Community & Support
- [Cisco Community Forum](https://community.cisco.com/t5/webex-connect/bd-p/connect)
- [Webex Troubleshooting Guide](https://developer.webex.com/explore/docs/api/guides/troubleshooting)

---

*Generated by Webex Connect Debug Dashboard*
`;

                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'webex-widget-debug-documentation.md';
                a.click();
                URL.revokeObjectURL(url);
                showToast('Documentation exported!');
            }
        };

        // Add click handlers to nav items
        document.querySelectorAll('.help-nav-item').forEach(item => {
            item.addEventListener('click', function() {
                helpPanel.navigateTo(this.dataset.section);
            });
        });

        // Close on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && helpPanel.panel.classList.contains('show')) {
                helpPanel.close();
            }
        });
    </script>
</body>
</html>
